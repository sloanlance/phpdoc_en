<?xml version="1.0" encoding="iso-8859-1"?>
<!-- $Revision: 1.20 $ -->
<appendix id="migration">
 <title>Mirgrando do PHP/FI para o PHP 3</title>

 <section id="migration.about">
  <title>Sobre as incompatibilidades do 3.0</title>

  <simpara>
   PHP 3.0 foi totalmente reescrito. Ele tem um parser apropriado 
   que &eacute; muito mais robusto e consistente que o da vers&atilde;o 2.0. 3.0 
   &eacute; tamb&eacute;m significamente mais r&aacute;pido, e usa menos mem&oacute;ria. Entretanto 
   algumas dessas melhorias n&atilde;o seriam poss&iacute;veis sem mudan&ccedil;as na compatibilidade, 
   na sintaxe e na funcionalidade.
  </simpara>

  <simpara>
   Al&eacute;m do mais, os desenvolvedores do PHP tentaram limpar ambas 
   sintaxe e sem&acirc;nticas da vers&atilde;o 3.0 do PHP, e isto tamb&eacute;m traz algumas 
   incompatbilidades. A longo prazo, n&oacute;s acreditamos que estas mudan&ccedil;as 
   s&atilde;o para melhor.
  </simpara>

  <simpara>
   Este cap&iacute;tulo tentar&aacute; guiar voc&ecirc; com as incompatibilidades que voc&ecirc; 
   encontrar&aacute; quando estiver migrando do PHP/FI 2.0 para o PHP 3.0 e 
   ajudar&aacute; a resolver elas. Novas caracter&iacute;sticas n&atilde;o s&atilde;o mencionadas aqui 
   a menos que seja necess&aacute;rio.
  </simpara>

  <simpara>
   Um programa que converte automaticamente seus scripts em PHP/FI 2.0 existe. 
   Ele pode ser encontrado no subdiret&oacute;rio <filename class="directory">convertor</filename> 
   da distribui&ccedil;&atilde;o do PHP 3.0. Este programa apenas capta altera&ccedil;&otilde;es de sintaxe, 
   portanto voc&ecirc; deve ler atentamente este cap&iacute;tulo.
  </simpara>
 </section>

 <section id="migration.startendtags">
  <title>Tags de Come&ccedil;o/fim</title>

  <para>
   A primeira coisa que voc&ecirc; provavelmente ir&aacute; reparar &eacute; que as tags de 
   come&ccedil;o e fim do PHP mudaram. O velho foi <literal>&lt;? &gt;</literal> 
   modificado para tr&ecirc;s formas poss&iacute;veis:
   <example>
    <title>Migrando: da velha tag come&ccedil;o/fim</title>
    <programlisting role="php">
<![CDATA[
<? echo "Este &eacute; um c&oacute;digo em PHP/FI 2.0.\n"; >
]]>
    </programlisting>
   </example>
   Como na vers&atilde;o 2.0, PHP/FI tamb&eacute;m suporta esta varia&ccedil;&atilde;o:
   <example>
    <title>Migrando: primeira forma das tags come&ccedil;o/fim</title>
    <programlisting role="php">
<![CDATA[
<? echo "Este &eacute; um c&oacute;digo em PHP 3.0!\n"; ?>
]]>
    </programlisting>
   </example>

   Repare que a tag de fechamento agora consiste em um sinal de interroga&ccedil;&atilde;o e uma 
   tag de fechamento e n&atilde;o apenas em uma tag de fechamento. Entretanto, se 
   voc&ecirc; planeja usar XML no seu servidor, voc&ecirc; obeter&aacute; alguns problemas com a 
   nova varia&ccedil;&atilde;o, porque o PHP pode tentar executar as tags de marca&ccedil;&atilde;o dos 
   documentos em XML como c&oacute;digos PHP. Por causa disto, a seguinte modifica&ccedil;&atilde;o 
   foi adicionada:

   <example>
    <title>Migrando: segunda forma das tags come&ccedil;o/fim</title>
    <programlisting role="php">
<![CDATA[
<?php echo "Este &eacute; um c&oacute;digo em PHP 3.0!\n"; ?>
]]>
    </programlisting>
   </example>

   Algumas pessoas obtiveram problemas com editores que n&atilde;o entendem 
   todas as tags de processamento. O Microsoft Frontpage &eacute; um destes editores, 
   e pensando nestes editores, foi adicionado mais uma modifica&ccedil;&atilde;o que &eacute; mostrada
   abaixo:

   <example>
    <title>Migrando: terceira forma das tags come&ccedil;o/fim</title>
    <programlisting role="php">
<![CDATA[
<script language="php">

  echo "Este &eacute; um c&oacute;digo em PHP 3.0!\n";

</script>
]]>
    </programlisting>
   </example>
  </para>
 </section>

 <section id="migration.if-endif">
  <title>sintaxe if..endif</title>

  <para>
   A maneira 'alternativa' de escrever as instru&ccedil;&otilde;es if/elseif/else , usando if(); 
   elseif(); else; endif; n&atilde;o puderam ser eficientemente implementadas sem adicionar 
   uma quantidade grande de complexidade ao parser 3.0. Por causa disso, a sintaxe foi 
   alterada para:
   <example>
    <title>Migrando: velha sintaxe if..endif</title>
    <programlisting role="php">
<![CDATA[
if ($foo);
    echo "sim\n";
elseif ($bar);
    echo "quase\n";
else;
    echo "n&atilde;o\n";
endif;
]]>
    </programlisting>
   </example>
   <example>
    <title>Migrando: nova sintaxe if..endif</title>
    <programlisting role="php">
<![CDATA[
if ($foo):
    echo "sim\n";
elseif ($bar):
    echo "quase\n";
else:
    echo "n&atilde;o\n";
endif;
]]>
    </programlisting>
   </example>

   Repare que todos os pontos-e-v&iacute;rgulas foram trocados por dois-pontos em todas
   as instru&ccedil;&otilde;es, exceto na instru&ccedil;&atilde;o de fechamento (endif).
  </para>
 </section>

 <section id="migration-while">
  <title>sintaxe while</title>
  <para>
   Assim como o if...endif, a sintaxe do while...endwhile foi alterada:
   <example>
    <title>Migrando: a velha sintaxe do while..endwhile</title>
    <programlisting role="php">
<![CDATA[
while ($mais_a_vir);
    ...
endwhile;
]]>
    </programlisting>
   </example>
   <example>
    <title>Migrando: nova sintaxe do while..endwhile</title>
    <programlisting role="php">
<![CDATA[
while ($mais_a_vir):
    ...
endwhile;
]]>
    </programlisting>
   </example>
  </para>
  <warning>
   <simpara>
    Se voc&ecirc; usar a velha sintaxe do while...endwhile no PHP 3.0, 
	voc&ecirc; ir&aacute; obter um loop que nunca-termina.
   </simpara>
  </warning>
 </section>

 <section id="migration.expr">
  <title>Tipos de Express&otilde;es</title>
  <simpara>
   O PHP/FI 2.0 usa o lado esquerdo das express&otilde;es para determinar qual o tipo 
   de resultado que deve retornar. O PHP 3.0 examina ambos os lados quando 
   determina os tipos de resultados, e isto pode fazer com que scripts da vers&atilde;o 
   2.0 comportem-se inesperadamente.
  </simpara>
  <para>
   Considere este exemplo:
   <informalexample>
    <programlisting role="php">
<![CDATA[
$a[0]=5;
$a[1]=7;

$key = key($a);
while ("" != $key) {
    echo "$keyn";
    next($a);
}
]]>
    </programlisting>
   </informalexample>

   No PHP/FI 2.0, isto mostraria ambos os &iacute;ndices de $a. No PHP 3.0, 
   isto n&atilde;o mostraria nada. A raz&atilde;o &eacute; que no PHP 2.0, &eacute; porque os argumentos 
   da esquerda eram do tipo string, ent&atilde;o uma compara&ccedil;&atilde;o de string foi feita, 
   e certamente <literal>""</literal> n&atilde;o &eacute; igual &agrave; <literal>"0"</literal>, e o 
   la&ccedil;o &eacute; completado. No PHP 3.0, quando uma string &eacute; comparada com um inteiro, uma 
   compara&ccedil;&atilde;o de inteiro &eacute; feita (a string &eacute; convertida para inteiro). Isto resultado em uma 
   compara&ccedil;&atilde;o em que <literal>atoi("")</literal> &eacute; <literal>0</literal>, e <literal>variablelist</literal> 
   tamb&eacute;m &eacute; <literal>0</literal>, deste que <literal>0==0</literal>, o loop n&atilde;o executa mais de uma vez.
  </para>
  <para>
   A corre&ccedil;&atilde;o para iso &eacute; simples. Troque aquele while por:
   <informalexample>
    <programlisting role="php">
<![CDATA[
while ((string)$key != "") {
]]>
    </programlisting>
   </informalexample>
  </para>
 </section>

 <section id="migration.errors">
  <title>Mensagens de erro foram alteradas</title>
  <simpara>
   No PHP 3.0 as mensagens de erro geralmente s&atilde;o mais exatadas do que as do PHP 2.0, 
   mas voc&ecirc; n&atilde;o ver&aacute; mais o fragmento de c&oacute;digo que cont&eacute;m o erro. Voc&ecirc; ser&aacute; notificado 
   com o nome do arquivo e o n&uacute;mero da linha onde ocorreu o erro.
  </simpara>
 </section>

 <section id="migration.booleval">
  <title>Short-circuited boolean evaluation</title>
  <simpara>
   No PHP 3.0 a avalia&ccedil;&atilde;o booleana &eacute; short-circuited. Isto significa que 
   uma express&atilde;o como esta <literal>(1 || teste_me())</literal>, da fun&ccedil;&atilde;o 
   <function>teste_me</function> n&atilde;o seria executada porque nada pode mudar 
   o resultado da express&atilde;o ap&oacute;s <literal>1</literal>.
  </simpara>

  <simpara>
   Esta &eacute; uma pequena incompatibilidade, mas poder&aacute; causar side-effects 
   inesperados.
  </simpara>
 </section>

 <section id="migration.truefalse">
  <title>Fun&ccedil;&otilde;es &true;/&false; retornam valores</title>
  <simpara>
   A maioria das fun&ccedil;&otilde;es foram reescritas sendo assim, retornam &true; 
   quando obt&eacute;m sucesso e &false; quando falham, ao contr&aacute;rio de 0 e -1 no 
   PHP/FI 2.0, respectivamente. O novo comportamento permite um c&oacute;digo mais 
   l&oacute;gico, como <literal>$fp = fopen("/seu/arquivo") or fail("merda!");</literal>. 
   Porque o PHP/FI 2.0 n&atilde;o tem regras claras quanto ao que a fun&ccedil;&atilde;o dever&aacute; retornar 
   caso falhe, muitos scripts provavelmente dever&atilde;o ser checados manualmente ap&oacute;s usar 
   o conversor de 2.0 para 3.0.
  </simpara>
  <para>
   <example>
    <title>Migrando do 2.0: retornando valores, c&oacute;digo antigo</title>
    <programlisting role="php">
<![CDATA[
$fp = fopen($arquivo, "r");
if ($fp == -1);
    echo("N&atilde;o foi poss&iacute;vel abrir $arquivo para leitura<br>\n");
endif;
]]>
    </programlisting>
   </example>
   <example>
    <title>Migrando do 2.0: retornando valores, novo c&oacute;digo</title>
    <programlisting role="php">
<![CDATA[
$fp = @fopen($arquivo, "r") or print("N&atilde;o foi poss&iacute;vel abrir $arquivo para leitura<br>\n");
]]>
    </programlisting>
   </example>
  </para>
 </section>

 <section id="migration-other">
  <title>Outras incompatibilidades</title>

  <itemizedlist>
   <listitem><simpara>
    O m&oacute;dulo do PHP 3.0 para o Apache n&atilde;o suporta vers&otilde;es anteriores &agrave; 1.2. 
	Apache 1.2 ou atual &eacute; requerido.
   </simpara></listitem>

   <listitem><simpara>
    <function>echo</function> n&atilde;o suporta mais strings formatadas. 
    Use a fun&ccedil;&atilde;o <function>printf</function> para isto.
   </simpara></listitem>

   <listitem><simpara>
    No PHP/FI 2.0, uma execu&ccedil;&atilde;o "side-effect" faz com que <literal>$foo[0]</literal> 
	tenha o mesmo efeito que <literal>$foo</literal>. No PHP 3.0 isto n&atilde;o &eacute; verdadeiro.
   </simpara></listitem>

   <listitem>
    <simpara>
	 Ler arrays com <literal>$array[]</literal> n&atilde;o &eacute; mais 
	 suportado
    </simpara>
    <simpara>
	 Isto &eacute;, voc&ecirc; n&atilde;o pode atravessar um array fazendo um loop que cont&eacute;m <literal>$data = $array[]</literal>. 
	 Ao inv&eacute;s disso use <function>current</function> e <function>next</function>.
    </simpara>
    <simpara>
	 Tamb&eacute;m, <literal>$array1[] = $array2</literal> n&atilde;o adiciona 
	 valores de <literal>$array2</literal> &agrave; <literal>$array1</literal>, 
	 mas adiciona <literal>$array2</literal> como a &uacute;ltima entrada de 
	 <literal>$array1</literal>. Veja tamb&eacute;m o suporte ao array multidimensional.
    </simpara>
   </listitem>

   <listitem>
    <simpara>
     <literal>"+"</literal> n&atilde;o &eacute; mais considerado como um concatenador de 
	 strings, ao inv&eacute;s disso &eacute; usado para converter argumentos para n&uacute;meros 
	 e executar adi&ccedil;&otilde;es n&uacute;mericas. Use <literal>"."</literal> para concatenar.
    </simpara>
   </listitem>
  </itemizedlist>

  <example>
   <title>Migrando do 2.0: concatena&ccedil;&atilde;o de strings</title>
   <programlisting role="php">
<![CDATA[
echo "1" + "1";
]]>
   </programlisting>
   <para> 
    No PHP 2.0 isto retornaria echo 11, no PHP 3.0 isto 
	retornar&aacute; echo 2. Ao inv&eacute;s disso use:
    <programlisting role="php">
<![CDATA[
echo "1"."1";
]]>
    </programlisting>
    <programlisting role="php">
<![CDATA[
$a = 1;
$b = 1;
echo $a + $b;
]]>
    </programlisting>
   </para>
   <para>
    Isto ir&aacute; retornar echo 2 em ambas vers&otilde;es do PHP 2.0 e 3.0.
    <programlisting role="php">
<![CDATA[
$a = 1;
$b = 1;
echo $a.$b;
]]>
    </programlisting>
	Isto retornar&aacute; echo 11 no PHP 3.0.
   </para>
  </example>
 </section>

</appendix>

<!-- Keep this comment at the end of the file
Local variables:
mode: sgml
sgml-omittag:t
sgml-shorttag:t
sgml-minimize-attributes:nil
sgml-always-quote-attributes:t
sgml-indent-step:1
sgml-indent-data:t
indent-tabs-mode:nil
sgml-parent-document:nil
sgml-default-dtd-file:"../../manual.ced"
sgml-exposed-tags:nil
sgml-local-catalogs:nil
sgml-local-ecat-files:nil
End:
vim600: syn=xml fen fdm=syntax fdl=2 si
vim: et tw=78 syn=sgml
vi: ts=1 sw=1
-->
