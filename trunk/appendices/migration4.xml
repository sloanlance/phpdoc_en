<?xml version="1.0" encoding="iso-8859-1"?>
<!-- $Revision: 1.26 $ -->
 <appendix id="migration4">
  <title>Migrando do PHP 3 para o PHP 4</title>
	
  <section id='migration4.changes'>
   <title>O que mudou no PHP 4</title>
   <para>
    O PHP 4 e a integra&ccedil;&atilde;o com o engine Zend melhoraram incrivelmente a 
	performance e potencialidades do PHP, mas foi tomado o cuidado  
	de deixar o c&oacute;digo existente o m&aacute;ximo poss&iacute;vel. Sendo assim, migrar seu 
	c&oacute;digo do PHP 3 para PHP 4 &eacute; muito mais f&aacute;cil do que migrar do PHP/FI 2 para PHP 3. 
	Muitos c&oacute;digos existentes do PHP 3 podem rodar sem altera&ccedil;&otilde;es, mas voc&ecirc; dever&aacute; 
	ficar atento as diferenta&ccedil;as e ter o cuidado de testar seu c&oacute;digo antes de trocar as 
	vers&otilde;es nos sistemas de produ&ccedil;&otilde;es. O material abaixo dever&aacute; dar &agrave; 
	voc&ecirc; algumas instru&ccedil;&otilde;es sobre o que procurar.
   </para>
  </section>

  <section id="migration4.php4.with.php3">
   <title>Rodando PHP 3 e PHP 4 simultaneamente</title>
   <simpara>
    Os sistemas operacionais atuais fornecem a habilidade de de 
	executar "versioning" e "scoping". Estas caracter&iacute;sticas 
	tornam poss&iacute;vel deixar-mos o PHP 3 e PHP 4 rodando simultaneamente 
	como m&oacute;dulos em um s&oacute; servidor Apache.
   </simpara>
   <simpara>
    Esta op&ccedil;&atilde;o &eacute; suportada nas seguintes plataformas:
   </simpara>
   <itemizedlist>
     <listitem><simpara>Linux com os recentes binutils (binutils 2.9.1.0.25 testado) </simpara></listitem>
     <listitem><simpara>Solaris 2.5 ou superior</simpara></listitem>
     <listitem><simpara>FreeBSD (3.2, 4.0 testado)</simpara></listitem>
   </itemizedlist>
   <para>
    Para habilitar isto, configure seu PHP 3 e PHP 4 usando o APXS 
	(--with-apxs) e linkar as extens&otilde;es necess&aacute;rias (--enable-versioning). 
	Por outro lado, isto tamb&eacute;m se aplica para todas as instala&ccedil;&otilde;es padr&otilde;es. 
	Por exemplo:
    <informalexample>
     <programlisting role="configure">
<![CDATA[
$ ./configure \
  --with-apxs=/apache/bin/apxs \
  --enable-versioning \
  --with-mysql \
  --enable-track-vars
]]>
		 </programlisting>
		</informalexample>
   </para>
  </section>

  <section id="migration4.configuration">
   <title>Migrando os arquivos de configura&ccedil;&atilde;o</title>
   <para>
    O arquivo de configura&ccedil;&atilde;o global, <filename>php3.ini</filename>, 
	foi alterado para ete nome &php.ini;.
   </para>
   <para>
    Para o arquivo de configura&ccedil;&atilde;o do Apache, h&aacute; algumas pequenas 
	mudan&ccedil;as. Os tipos de MIME reconhecidos pelo m&oacute;dulo do PHP foram 
	alterados.
    <informalexample>
		 <programlisting role="apache">
<![CDATA[
application/x-httpd-php3        -->    application/x-httpd-php
application/x-httpd-php3-source -->    application/x-httpd-php-source
]]>
		 </programlisting>
		</informalexample>
   </para>
   <para>
    Você pode fazer seu arquivo de configuração trabalhar com ambas as 
	versões do PHP (dependendo de qual compilação está no servidor), 
	usando a seguinte sintaxe:
    <informalexample>
		 <programlisting>
<![CDATA[
AddType  application/x-httpd-php3        .php3
AddType  application/x-httpd-php3-source .php3s

AddType  application/x-httpd-php         .php
AddType  application/x-httpd-php-source  .phps
]]>
     </programlisting>
		</informalexample>
   </para>
   <simpara>
    Al&eacute;m disso, os nomes das diretiva do PHP para o Apache foram alteradas.
   </simpara>
   <para>
    Come&ccedil;ando com o PHP 4.0, h&aacute; quatro diretivas para o Apache relacionadas 
	ao PHP:
    <informalexample>
		 <programlisting role="apache">
<![CDATA[
php_value [PHP directive name] [value]
php_flag [PHP directive name] [On|Off]
php_admin_value [PHP directive name] [value]
php_admin_flag [PHP directive name] [On|Off]
]]>
		 </programlisting>
		</informalexample>
   </para>
   <simpara>
    H&aacute; duas diferen&ccedil;as entre os valores do Admin e do n&atilde;o admin:
   </simpara>
   <itemizedlist>
    <listitem><simpara>Os valores Admin (ou os flags) s&oacute; aparecem no server-wide dos arquivos de configura&ccedil;&atilde;o 
	do apache (e.g., httpd.conf).</simpara></listitem>
	<listitem><simpara>Os valores padr&otilde;es (ou os flags) n&atilde;o podem controlar determinadas diretivas do PHP, 
	por exemplo - safe mode (se voc&ecirc; pude-se cancelar as configura&ccedil;&otilde;es do modo seguro em arquivos .htacces, 
	isto desativaria o modo-seguro). Em contraste, os valores Admin podem modificar qualquer diretiva do PHP.</simpara></listitem>.
   </itemizedlist>
   <simpara>
    Para tornar o processo de transi&ccedil;&atilde;o mais f&aacute;cil, o PHP 4 vem com scripts que convertem automaticamente 
	suas configura&ccedil;&otilde;es do Apache e arquivos .htacces para trabalharem com ambos PHP 3 e PHP 4. Estes scripts 
	N&Atilde;O convertem as linhas do tipo MIME! Voc&ecirc; ter&aacute; que converter manualmente.
   </simpara>
   <para>
    Para converter seus arquivos de configura&ccedil;&atilde;o do Apache, rode o script apconf-conv.sh (distpon&iacute;vel no 
	diret&oacute;rio /scripts/apache). Exemplo:
    <informalexample>
		 <programlisting role="shell">
<![CDATA[
~/php4/scripts/apache:#  ./apconf-conv.sh /usr/local/apache/conf/httpd.conf
]]>
		 </programlisting>
		</informalexample>
   </para>
   <simpara>
    Seu arquivo de configura&ccedil;&atilde;o original ser&aacute; salve como httpd.conf.orig.
   </simpara>
   <para>
    Para converter seus arquivos .htaccess, rode o script aphtaccess-conv.sh (dispon&iacute;vel no 
	diret&oacute;rio scripts/apache), exemplo:
    <informalexample>
		 <programlisting role="shell">
<![CDATA[
~/php4/scripts/apache:#  find / -name .htaccess -exec ./aphtaccess-conv.sh {} \;
]]>
		 </programlisting>
		</informalexample>
   </para>
   <simpara>
    Como j&aacute; foi dito, seus antigos arquivos .htacces ser&atilde;o salvos com o prefixo .orig.
   </simpara>
   <simpara>
    A convers&atilde;o dos scripts requer que o awk esteja instalado.
   </simpara>
  </section>

  <section id='migration4.parser'>
   <title>Comportamento da Análise</title>
   <para>
    A execução e a análise são agora duas etapas completamente separadas, 
	nenhuma execução de código de arquivo será acontecerá até que tudo seja 
	completado e analisado completamente.
   </para>
   <para>
    Uma das novas exig&ecirc;ncias introduzidas com este split &eacute; que 
	arquivos requeridos e inclu&iacute;dos agora tem que estar sintaticamente 
	completos. Voc&ecirc; n&atilde;o pode mais espalhar os em diferentes partes os 
	controles de estrutura ou espalahar os controles atrav&eacute;s de arquivos. 
	Voc&ecirc; n&atilde;o pode come&ccedil;ar um la&ccedil;o <literal>for</literal> ou <literal>while</literal>, 
	um bloco de instru&ccedil;&otilde;es <literal>if</literal> ou <literal>switch</literal> come&ccedil;ando 
	em um arquivo e terminar o loop, <literal>else</literal>, <literal>endif</literal>, 
	<literal>case</literal> ou <literal>break</literal> em um arquivo diferente.
   </para>
   <para>
    Ainda &eacute; permitido incluir c&oacute;digos adicionaisdentro dos la&ccedil;os ou 
	estruturas de controle, somente os controles chaves e os correspondentes 
	<literal>(....)</literal> tem que estar compilados na mesma unidade 
	(arquivo ou <function>eval</function>ed string).
   </para>
   <para>
    Isto n&atilde;o deve prejudicar muito considerando que um c&oacute;digo como este 
	&eacute; considerado mal feito de qualquer maneira.
   </para>
   <para>
    Outra coisa que n&atilde;o &eacute; mais poss&iacute;vel, e que &eacute; raramente visto em um c&oacute;digo 
	PHP 3 &eacute; o retorno de valores de um requerido arquivo. Retornar valores 
	de um arquivo inclu&iacute;do ainda &eacute; poss&iacute;vel.
   </para>
  </section>

  <section id='migration4.error-reporting'>
   <title>Relatório de erros</title>
	 
   <section id='migration4.error-reporting.config'>
    <title>Mudan&ccedil;as na Configura&ccedil;&atilde;o</title>
    <para>
	 O relat&oacute;rio de erro do PHP 3 foi ajustado para um simples 
	 valor n&uacute;mero formado pela soma de n&uacute;meros relacionados aos 
	 diferentes n&iacute;veis de erro. Valores usuais onde 15 para relatar 
	 todos os erros e mensagens ou 7 para relatar qualquer coisa mas 
	 simples observa&ccedil;&atilde;o ao mal estilo e coisas como esta.
    </para>
    <para>
	 PHP 4 cont&eacute;m um maior n&iacute;vel de erros e avisos e vem com uma 
	 configura&ccedil;&atilde;o do parser que agora permite que constantes simb&oacute;licas 
	 sejam usadas para para ajustar ao comportamente pretendido.
    </para>
    <para>
	 O n&iacute;vel do relat&oacute;rio de erro agora pode ser configurado explicitamente 
	 removendo os n&iacute;veis de advert&ecirc;ncia que voc&ecirc; n&atilde;o quer gerar nas suas 
	 mensagens de erro x-oring da constante simb&oacute;lica <literal>E_ALL</literal>. 
	 Parece complicado? Bem, vamos dizer que voc&ecirc; quer todas as advert&ecirc;ncias 
	 categorizadas na constante simb&oacute;lica <literal>E_NOTICE</literal>. Ent&atilde;o voc&ecirc; 
	 dever&aacute; colocar o seguinte em seu &php.ini;: <literal>error_reporting = 
	 E_ALL &amp; - ( E_NOTICE )</literal>. Se voc&ecirc; quiser suprir as 
	 advert&ecirc;ncias voc&ecirc; deve adicionar a constante apropriada dentro do 
	 par&ecirc;ntese usando o operador '|': 
	 <literal>erro_reporting = E_ALL &amp; ~ ( E_NOTICE | E_WARNING )</literal>.
    </para>
    <warning>
     <para>
	  Ao atualizar c&oacute;digos ou servidores do PHP 3 para PHP 4 voc&ecirc; 
	  deve checar as configura&ccedil;&otilde;es e chamadas ao <function>error_reporting</function> 
	  ou voc&ecirc; deve desabilitar os novos tipos de relat&oacute;rio de erro, 
	  especialmente E_COMPILE_ERROR. Isto pode ocasionar a limpeza de 
	  documents sem nenhuma resposta do que ocorreu ou onde procurar 
	  pelo problema.
     </para>
    </warning>
    <warning>
     <para>
	  Usando valores menores que 7 ou 15 para ajustar o relat&oacute;rio 
	  de erro n&atilde;o &eacute; uma boa id&eacute;ia porque pode suprir algumas das 
	  classes de erros adicionadas no parser de erros. Isto pode causar 
	  um comportamento estranho com os scripts e tamb&eacute;m n&atilde;o ir&aacute; 
	  mostrar nenhuma mensagem de erro em nenhum lugar.
     </para>
     <para>
	  No passa isto causou muitas inconveni&ecirc;ncias porque as 
	  pessoas relatavam problemas nos scripts e na verdade 
	  n&atilde;o eram capazes de consertar erros comuns, como a falta de 
	  um '}' requerido em um arquivo que era passado e que o 
	  parser n&atilde;o era capaz de reportar um erro que era apenas 
	  um erro de uma falta de configura&ccedil;&atilde;o no sistema.
     </para>
     <para>
	  Ent&atilde;o checar a sua configura&ccedil;&atilde;o do relat&oacute;rio de erros 
	  deve ser a primeira coisa a fazer quando os seus scripts 
	  causam erros silenciosos. O engine da Zend pode ser 
	  considerado maduro o bastante nos dias atuais para n&atilde;o 
	  causar estes tipos de erros estranhos.
     </para>
    </warning>
   </section>

   <section id='migration4.error-reporting.additions'>
    <title>Mensagens de advert&ecirc;ncia adicionais</title>
    <para>
	 Muitos c&oacute;digos PHP 3 existentes usam uma linguagem de estrutura 
	 que pode ser considerado um c&oacute;digo mal formatado, o que pode 
	 tornar as coisas f&aacute;ceis agora, pode facilmente ser quebrado 
	 por mudan&ccedil;as em outros lugares. PHP 4 exibe muitas mensagens 
	 de advert&ecirc;ncia em situa&ccedil;&otilde;es onde o PHP 3 n&atilde;o o fazia. O jeito 
	 f&aacute;cil de consertar isto &eacute; setar para off as mensagens E_NOTICE, 
	 mas geralmente &eacute; sempre bom consertar o c&oacute;digo.
    </para>
    <para>
	 O caso mais comum que agora ir&aacute; produzir mensagens de advert&ecirc;ncia 
	 &eacute; o uso de constantes de strings n&atilde;o quotadas como &iacute;ndices de array. 
	 Ambos PHP 3 e PHP 4 tentar&atilde;o interpretarar isto como se fosse strings 
	 se nenhuma palavra ou constante for conhecida pelo nome, mas sempre que 
	 uma constante por esse nome for definida em qualquer lugar do c&oacute;digo 
	 ela pode causar erros no script. Isto pode se tornar um risco de 
	 seguran&ccedil;a se um invasor redefinir as strings constantes &agrave; um 
	 caminho que faz o seu script dar as permiss&otilde;es corretas que ele 
	 n&atilde;o deveria ter. Ent&atilde;o o PHP 4 agora avisa voc&ecirc; sempre que 
	 voc&ecirc; usar strings constantes n&atilde;o quotadas por exemplo no 
	 <literal>$_SERVER[REQUEST_METHOD]</literal>. Altere isto para 
	 <literal>$_SERVER['REQUEST_METHOD']</literal> que far&aacute; 
	 com que o parser fique feliz e melhorar&aacute; extremamente o 
	 estilo e seguran&ccedil;a do seu c&oacute;digo.
    </para>
    <para>
	 Outra coisa que o PHP 4 agora lhe informa &eacute; sobre o uso 
	 de vari&aacute;veis ou elementos de array n&atilde;o inicializados.
    </para>
   </section>
   
  </section>

  <section id='migration4.initializers'>
   <title>Inicializadores</title>
   <para>
    Os inicializadores de vari&aacute;veis est&aacute;ticas e membros de classes 
	aceitam somente valores escalares enquanto no PHP 3 eles aceitavam 
	qualquer express&atilde;o v&aacute;lida. Isto &eacute;, mais uma vez, devido ao corte entre 
	a execu&ccedil;&atilde;o e o parsing como nenhum c&oacute;digo executado quando o parser 
	v&ecirc; o inicializador.
   </para>
   <para>
    Para classes voc&ecirc; deve usar construtores para inicializar 
	membros ao inv&eacute;s de vari&aacute;veis. Para vari&aacute;veis est&aacute;ticas 
	pode-se usar qualquer coisa mas raramente uma simples 
	vari&aacute;vel est&aacute;tira faz algum sentido.
   </para>
  </section>

  <section id='migration4.empty'>
   <title><literal>empty("0")</literal></title>
   <para>
	Talvez a mudan&ccedil;a mais controversa no comportamento aconteceu na fun&ccedil;&atilde;o 
	<function>empty</function>. Uma string que cont&eacute;m somente caracteres 
	' 0 ' (zero) agora &eacute; considerada vazia enquanto no PHP 3 ela n&atilde;o era.
   </para>
   <para> 
    Estes novos comportamentos fazem sentido em aplicativos web, com todos 
	aqueles campos retornando strings mesmo se entradas n&uacute;mericas s&atilde;o requisitadas, 
	e com as capacidades do PHP automaticamente converter os tipos. Mas 
	por outro lado isto pode gerar problemas no seu c&oacute;digo de uma 
	maneira totalmente pertubadora, conduzindo ao um estranho comportamento 
	que &eacute; duro de consertar se voc&ecirc; n&atilde;o souber o que voc&ecirc; procura.
   </para>
  </section>

  <section id='migration4.missing'>
   <title>Fun&ccedil;&otilde;es abandonadas</title>
   <para>
    Enquanto o PHP 4 vem com uma s&eacute;rie de novas caracter&iacute;sticas, 
	fun&ccedil;&otilde;es e extens&otilde;es, voc&ecirc; talvez encontre algumas fun&ccedil;&otilde;es da 
	vers&atilde;o 3 que n&atilde;o existem mais. Um pequeno n&uacute;mero de fun&ccedil;&otilde;es 
	do n&uacute;cleo desapareceu porque elas n&atilde;o funcionavam com o novo 
	sistema de execu&ccedil;&atilde;o e parsing introduzido na vers&atilde;o 4 com a 
	Zend engine. Outras fun&ccedil;&otilde;es e mesmo extens&otilde;es se tornaram 
	obsoletas para as novas fun&ccedil;&otilde;es e extens&otilde;es que servem a 
	mesma tarefa melhor e/ou de uma maneira geral. Algumas fun&ccedil;&otilde;es 
	simplesmente n&atilde;o foram portadas ainda e finalmente algumas 
	fun&ccedil;&otilde;es ou extens&otilde;es podem ter sido retiradas por conflitos 
	de licen&ccedil;a.
   </para>

   <section id='migration4.missing.concept'>
    <title>Funções abandonadas devido à mudanças conceptuais</title>
    <para>
	 Como o PHP 4 agora separa o parsing da execu&ccedil;&atilde;o n&atilde;o &eacute; mais poss&iacute;vel 
	 alterar o comportamento do parser (agora embutido na Zend engine) 
	 na hora da execu&ccedil;&atilde;o quando o parsing j&aacute; aconteceu. Ent&atilde;o a fun&ccedil;&atilde;o 
	 <function>short_tags</function> n&atilde;o existe mais. Voc&ecirc; ainda 
	 pode mudar o comportamento dos parsers setando o valor 
	 propriedade no arquivo &php.ini.
    </para>
    <para>
	 Outra caracter&iacute;sticas do PHP 3 que n&atilde;o faz parte do PHP 4 &eacute; 
	 a rela&ccedil;&atilde;o embutida de eliminar erros. Existem add-ons de terceiros 
	 para a Zend engine que adicionam um funcionamento similar.
    </para>
   </section>

   <section id='migration4.deprecate'>
    <title>Depcritamento de fun&ccedil;&otilde;es e extens&otilde;es</title>
    <para>
	 As extens&otilde;es dos banco de dados Adabas e Solid n&atilde;o existem mais. 
	 Ao in&eacute;s delas foi unificado o ODBC.
    </para>
   </section>

   <section id='migration4.unset'>
    <title>Mudan&ccedil;a de status para <function>unset</function></title>
    <para>
     <function>unset</function>, embora ainda dispon&iacute;vel, &eacute; 
	 implementado como um construtor de linguagem melhor que uma fun&ccedil;&atilde;o.
    </para>
    <para>
	Isto n&atilde;o tem nenhumas conseq&uuml;&ecirc;ncias no comportamento < de function>unset, mas testar para "unset" usando < function>function_exists retornar&aacute; o &false; porque com outras constru&ccedil;&otilde;es da l&iacute;ngua que olham como fun&ccedil;&otilde;es tais como < function>echo. 
	 Isto n&atilde;o interfere em nada no comportamento do 
	 <function>unset</function>, mas testar "unset" usando 
	 <function>function_exists</function> retornar&aacute; &false; 
	 porque com outros construtores de linguagens que observam 
	 func&ccedil;&otilde;es tais como o <function>echo</function>.
    </para>
    <para>
	 Uma otura mudan&ccedil;a mais pr&aacute;tica &eacute; que n&atilde;o &eacute; mais poss&iacute;vel chamar 
	 <function>unset</function> indiretamente, isso &eacute;, <literal>$func="unset"; $func($algumavar)</literal> 
	 n&atilde;o ir&aacute; mais funcionar.
    </para>
   </section>
  </section>

  <section id='migration4.extensions'>
   <title>Extens&otilde;es PHP 3</title>
   <para>
    Extens&otilde;es escritas para o PHP 3 n&atilde;o ir&atilde;o funcionar com o PHP 4, 
	nem como bin&aacute;rias nem no c&oacute;digo fonte. N&atilde;o &eacute; dif&iacute;cil portar estas 
	extens&otilde;es para o PHP 4 se vc&ecirc; tiver acesso aos fontes originais. 
	Uma descri&ccedil;&atilde;o detalhada do processo de porta&ccedil;&atilde;o n&atilde;o faz parte deste 
	texto.
   </para>
  </section>

  <section id='migration4.strings'>
   <title>Substitui&ccedil;&atilde;o de vari&aacute;veis nas strings</title>
   <para>
    O PHP 4 adiciona um novo mecanimos para a substitui&ccedil;&atilde;o 
	de vari&aacute;veis em strings. Agora voc&ecirc; finalmente pode acessar 
	as vari&aacute;veis de um objeto membro e seus elementos de um 
	array multidimensional dentro de strings.
   </para>
   <para>
    Para fazer isso voc&ecirc; tem que incluir nas suas vari&aacute;veis chaves 
	com o s&iacute;mbolo da moeda imediatamente ap&oacute;s a chave de abertura:
    <literal>{$...}</literal>
   </para>
   <para>
    Para embutir o valor de um objeto membro de uma vari&aacute;vel 
	dentro de uma string simplesmente escreva <literal>"texto {$obj-&gt;membro} texto"</literal>
	enquanto no PHP 3 voc&ecirc; tinha que usar uma coisa como esta 
	<literal>"texto ".$obj-&gt;membro." texto"</literal>.
   </para>
   <para>
    Isto gera um c&oacute;digo mais leg&iacute;vel, mas pode gerar problemas 
	em scripts existentes escritos para o PHP 3. Mas 
	voc&ecirc; pode facilmente char este tipo de problema procurando 
	por uma combina&ccedil;&atilde;o de caracteres <literal>{$</literal> 
	no seu c&oacute;digo e substituindo eles por 
	<literal>\{$</literal> usando sua ferramenta de 
	procura-e-substitui&ccedil;&atilde;o favorita.
    </para>
  </section>

  <section id='migration4.cookies'>
   <title>Cookies</title>
   <para>
    O PHP 3 tinha um mau h&aacute;bito de configurar os cookies na ordem 
	reversa das chamadas <function>setcookie</function> no seu c&oacute;digo. 
	O PHP 4 inibiu este mau h&aacute;bito e cria as linhas de cabe&ccedil;alhos 
	dos cookies exatamente na mesma ordem que voc&ecirc; definie no 
	seu c&oacute;digo.
   </para>
   <para>
    Isto pode gerar problemas no seu c&oacute;digo existente, mas o velho 
	comportamente era t&atilde;o estranho de se entender que mereceu 
	uma mudan&ccedil;a para previnir futuros problemas.
   </para>
  </section>

  <section id='migration4.variables'>
   <title>Manipula&ccedil;&atilde;o de vari&aacute;veis globais</title>
   <para>
    A manipula&ccedil;&atilde;o de vari&aacute;veis globais tinha o foco de ser 
	f&aacute;cil no PHP 3 e vers&otilde;es posteriores &agrave; PHP 4, mas este 
	foco mudou por medidas de seguran&ccedil;a. Enquanto em um 
	script PHP 3 o exemplo a seguir funciona normalmente, 
	no PHP 4 tem que se usar unset($GLOBALS["id"]);. Isto 
	&eacute; apenas uma introdu&ccedil;&atilde;o da manipula&ccedil;&atilde;o de vari&aacute;veis globais. 
	Voc&ecirc; dever&aacute; sempre usar $GLOBALS, com as novas vers&otilde;es 
	do PHP 4 voc&ecirc; &eacute; for&ccedil;ado a fazer isto na maioria dos casos. 
	Leia mais sobre este assunto em <link linkend="references.global">.
   </para>
   <example>
    <title>Migra&ccedil;&atilde;o das vari&aacute;veis globais</title>
    <programlisting role="php">
<![CDATA[
<?php
$id = 1;
function test()
{
    global $id;
    unset($id);
}
test();
echo($id); // This will print out 1 in PHP 4
?>
]]>
    </programlisting>
   </example>
  </section>

 </appendix>


<!-- Keep this comment at the end of the file
Local variables:
mode: sgml
sgml-omittag:t
sgml-shorttag:t
sgml-minimize-attributes:nil
sgml-always-quote-attributes:t
sgml-indent-step:1
sgml-indent-data:t
indent-tabs-mode:nil
sgml-parent-document:nil
sgml-default-dtd-file:"../../manual.ced"
sgml-exposed-tags:nil
sgml-local-catalogs:nil
sgml-local-ecat-files:nil
End:
vim600: syn=xml fen fdm=syntax fdl=2 si
vim: et tw=78 syn=sgml
vi: ts=1 sw=1
-->
