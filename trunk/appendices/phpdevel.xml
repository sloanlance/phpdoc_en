<?xml version="1.0" encoding="iso-8859-1"?>
<!-- $Revision: 1.21 $ -->
<appendix id="phpdevel">
 <title>Estentendo o PHP</title>

 <simpara></simpara>

 <sect1 id="phpdevel-addfunc">
  <title>Adicionando fun&ccedil;&otilde;es ao PHP</title>
  <sect2 id="phpdevel-addfunc-prototype">
   <title>Fun&ccedil;&atilde;o Prototype</title>
   <para>
    Todas as fun&ccedil;&otilde;es separecem com esta:
    <programlisting role="c">       
<![CDATA[
void php3_foo(INTERNAL_FUNCTION_PARAMETERS) {
     
}
]]>
    </programlisting>
	Mesmo se sua fun&ccedil;&atilde;o n&atilde;o pegar nenhum argumento, &eacute; assim 
	que ela &eacute; chamada.
    </para></sect2>

  <sect2 id="phpdevel-addfunc-args">
   <title>Argumentos das fun&ccedil;&otilde;es</title>
   <para>
    Os argumentos s&atilde;o sempre do tipo pval. Este tipo cont&eacute;m a uni&atilde;o 
	que cont&eacute;m o tipo atual do argumento. Ent&atilde;o, se sua fun&ccedil;&atilde;o 
	pegar dois argumentos, voc&ecirc; faria algo como a seguir no topo 
	da sua fun&ccedil;&atilde;o:
   </para>

   <para>
    <example>
     <title>Fetching function arguments</title>
     <programlisting role="c">
<![CDATA[
pval *arg1, *arg2;
if (ARG_COUNT(ht) != 2 || getParameters(ht,2,&arg1,&arg2)==FAILURE) {
   WRONG_PARAM_COUNT;
}
]]>
     </programlisting>
    </example>
    NOTA: Argumentos podem ser passados pelo valor ou pela refer&ecirc;ncia. 
	Em ambos os casos voc&ecirc; ir&aacute; precisar passar &amp;(pval *) para 
	o getParameters. Se voc&ecirc; quer checar se n'th foi 
	enviado por refer&ecirc;ncia ou n&atilde;o, voc&ecirc; pode usar a seguinte fun&ccedil;&atilde;o.
	ParameterPassedByReference(ht,n). Isto ir&aacute; retornar 1 ou 0.

   </para>
    
   <simpara>
    Quando voc&ecirc; muda qualquer argumento passado por refer&ecirc;ncia, 
	se eles foram emitidos por refer&ecirc;ncia ou pelo valor, voc&ecirc; 
	pode come&ccedil;ar a partir do par&acirc;metro chamado pela pval_destructor, 
	ou se for um ARRAY que voc&ecirc; quer adicionar, voc&ecirc; pode usar 
	fun&ccedil;&otilde;es similares &agrave;s do arquivo internal_functions.h que 
	manipula o return_value como um ARRAY.</simpara>

   <simpara>
    Tamb&eacute;m se voc&ecirc; mudar um par&acirc;metro para IS_STRING tenha 
	certeza de primeiro atribuir a string e o tamanho dela ao 
	estrdup()'ed, e somente mais tarde alterar o tipo para 
	IS_STRING. Se voc&ecirc; quiser alterar a string de um par&acirc;metro 
	que j&aacute; &eacute; IS_STRING ou IS_ARRAY voc&ecirc; deve rodar o pval_destructor 
	primeiro.</simpara></sect2>
   
  <sect2 id="phpdevel-addfunc-varargs">
   <title>Argumentos das Vari&aacute;veis de Fun&ccedil;&otilde;es</title>
   <para>
    Uma fun&ccedil;&atilde;o pode pegar um n&uacute;mero de vari&aacute;veis e argumentos. Se sua 
	fun&ccedil;&atilde;o precisa pegar 2 ou 3 argumentos, use as instru&ccedil;&otilde;es a seguir:</para>
    
   <para>
    <example>
     <title>Argumentos das Vari&aacute;veis de Fun&ccedil;&otilde;es</title>
     <programlisting role="c">
<![CDATA[
pval *arg1, *arg2, *arg3;
int arg_count = ARG_COUNT(ht);

if (arg_count < 2 || arg_count > 3 ||
    getParameters(ht,arg_count,&arg1,&arg2,&arg3)==FAILURE) {
    WRONG_PARAM_COUNT;
}
]]>
    </programlisting>
    </example></para></sect2>
     
  <sect2 id="phpdevel-addfunc-using-args">
   <title>Usando os Argumentos das Fun&ccedil;&otilde;es</title>
   <para>
    O tipo de cada argumento é armazenado no campo do tipo pval. 
	Este tipo pode ser qualquer um dos seguintes:
    
    <table>
     <title>Tipos Internos do PHP</title>
     <tgroup cols="2">
      <tbody>
       <row>
        <entry>IS_STRING</entry>
        <entry>String</entry>
       </row>
       <row>
        <entry>IS_DOUBLE</entry>
        <entry>Double-precision floating point</entry>
       </row>
       <row>
        <entry>IS_LONG</entry>
        <entry>Inteiro longo</entry>
       </row>
       <row>
        <entry>IS_ARRAY</entry>
        <entry>Array</entry>
       </row>
       <row>
        <entry>IS_EMPTY</entry>
        <entry>Nenhum(a)</entry>
       </row>
       <row>
        <entry>IS_USER_FUNCTION</entry>
        <entry>??</entry>
       </row>
       <row>
        <entry>IS_INTERNAL_FUNCTION</entry>
        <entry>?? (se alguma dessas n&atilde;o puder ser passada para uma fun&ccedil;&atilde;o - delete)</entry>
       </row>
       <row>
        <entry>IS_CLASS</entry>
        <entry>??</entry>
       </row>
       <row>
        <entry>IS_OBJECT</entry>
        <entry>??</entry>
       </row>
      </tbody>
     </tgroup>
    </table></para>

   <para>
    Se voc&ecirc; pegar um argumento de um tipo e quiser usar ele 
	como outro tipo, ou se voc&ecirc; somente quer for&ccedil;ar o argumento 
	a ser de um certo tipo, voc&ecirc; pode usar as seguintes fun&ccedil;&otilde;es 
	para convers&atilde;o:

    <programlisting role="c">
<![CDATA[
convert_to_long(arg1);
convert_to_double(arg1);
convert_to_string(arg1); 
convert_to_boolean_long(arg1); /* If the string is "" or "0" it becomes 0, 1 otherwise */
convert_string_to_number(arg1);  /* Converts string to either LONG or DOUBLE depending on string */
]]>
     </programlisting></para>
    
   <simpara>
    Estas fun&ccedil;&otilde;es fazem convers&otilde;es in-place. Elas n&atilde;o retornam nada.</simpara>

   <para>
    O argumento atual &eacute; armazenado na uni&atilde;o; os membros s&atilde;o:
    <itemizedlist>
     <listitem><simpara>IS_STRING: arg1-&gt;value.str.val</simpara></listitem>
     <listitem><simpara>IS_LONG: arg1-&gt;value.lval</simpara></listitem>
     <listitem><simpara>IS_DOUBLE: arg1-&gt;value.dval</simpara></listitem>
    </itemizedlist></para></sect2>
    
  <sect2 id="phpdevel-addfunc-memmgmt">
   <title>Gerenciamento de Mem&oacute;ria nas Fun&ccedil;&otilde;es</title>
   <simpara>
    Toda mem&oacute;rai necess&aacute;ria para uma fun&ccedil;&atilde;o deve ser alocada no 
	emalloc() ou estrdup(). Estes eventos de mem&oacute;ria s&atilde;o abstratos 
	e se parecem com as fun&ccedil;&otilde;es normais como a malloc() e strdup(). 
	A mem&oacute;ria deve ser liberada com efree().</simpara>

   <simpara>
	H&aacute; dois tipos de mem&oacute;ria neste programa: a mem&oacute;ria que &eacute; 
	retornada para o parser em uma vari&aacute;vel, e a mem&oacute;ria que &eacute; 
	temporariamente armazenada na sua fun&ccedil;&atilde;o interna. Quando 
	voc&ecirc; atribui uma string a uma vari&aacute;vel que &eacute; retornada ao 
	parser voc&ecirc; preicsa ter certeza de primeiro alocar a mem&oacute;ria 
	com o emalloc() ou estrdup(). Esta mem&oacute;ria n&atilde;o DEVE ser 
	liberada por voc&ecirc;, a menos que uma mesma fun&ccedil;&atilde;o sobreescreva 
	a fun&ccedil;&atilde;o original (esta pr&aacute;tica de programa&ccedil;&atilde;o 
	n&atilde;o &eacute; muito boa).</simpara>

   <simpara>
	Para toda mem&oacute;ria tempor&aacute;ria/permanente que voc&ecirc; necessitar 
	usar em suas fun&ccedil;&otilde;es voc&ecirc; deve usar as tr&ecirc;s fun&ccedil;&otilde;es 
	emalloc(), estrdup(), e efree(). Elas comportam-se EXATAMENTE 
	como suas fun&ccedil;&otilde;es contrapartes. Para qualquer uso da emalloc() ou estrdup() 
	voc&ecirc; deve usar efree() em algum ponto ou outro, a menos que ela 
	precise ficar at&eacute; o fim do programa; se n&atilde;o, haver&aacute; um escape de mem&oacute;ria. 
	O significado de "as fun&ccedil;&otilde;es comportam-se exatamente como suas contrapartes" 
	&eacute;: se voc&ecirc; usa efree() em algo que n&atilde;o era emalloc()'ed ou estrdup()'ed 
	voc&ecirc; deve come&ccedil;ar uma falha na segmenta&ccedil;&atilde;o. Ent&atilde;o por favor tome cuidado e 
	libere toda sua mem&oacute;ria desperdi&ccedil;ada.</simpara> 

   <simpara>
    Se voc&ecirc; compilar com "-DDEBUG", o PHP ir&aacute; imprimir uma lsita 
	de toda mem&oacute;ria que foi alocada e usada com o emalloc() e estrdup() 
	mas nunca foi liberda com o efree() quando ele acabar de rodar um 
	script especificado.</simpara></sect2>

  <sect2 id="phpdevel-addfunc-symtab">
   <title>Setando Vari&aacute;veis na Tabela de S&iacute;mbolos</title>
   <para>
    Um n&uacute;mero de macros est&aacute; dispon&iacute;vel para tornar f&aacute;cil o trabalho 
	de setar uma vari&aacute;vel na tabela de s&iacute;mbolos:
    
    <itemizedlist>
     <listitem><simpara>SET_VAR_STRING(name,value)</simpara></listitem>
     <listitem><simpara>SET_VAR_DOUBLE(name,value)</simpara></listitem>
     <listitem><simpara>SET_VAR_LONG(name,value)</simpara></listitem>
    </itemizedlist>
   </para>

   <warning>
    <para>
	 Tenha cuidado com a SET_VAR_STRING. Parte do valor deve ser 
	 malloc'ed manualmente porque o c&oacute;digo do gerenciador de mem&oacute;ria 
	 ir&aacute; tentar lbierar este ponteiro mais tarde. N&atilde;o passe 
	 mem&oacute;ria est&aacute;tica alocada na SET_VAR_STRING.
    </para>
   </warning>
    
   <simpara>
	A tabela de s&iacute;mbolos no PHP &eacute; implementada como uma tabela de misutra. 
	A toda hora, &amp;symbol_table &eacute; apontado para o 'principal' 
	s&iacute;mbolo da tabela, e active_symbol_table aponta para o 
	s&iacute;mbolo corrente da tabela (isto pode ser identificado no 
	in&iacute;cio, ou diferente, se voc&ecirc; estiver dentro da fun&ccedil;&atilde;o).</simpara>
  
   <para>
    O exemplo a seguir usa o 'active_symbol_table'. Voc&ecirc; 
	deve substituir isto por &amp;symbol_table se voc&ecirc; 
	quer especificamente trabalhar com a tabela de s&iacute;mbolos 
	'principal'. Tamb&eacute;m, as mesmas fun&ccedil;&otilde;es se apliquem &agrave; 
	arrays, como explicado a seguir.</para>
  
   <para>
    <example>
     <title>Checando se $foo existe na tabela de s&iacute;mbolos</title>
     <programlisting role="c">
<![CDATA[
if (hash_exists(active_symbol_table,"foo",sizeof("foo"))) { exists... }
else { doesn't exist }
]]>
     </programlisting>
    </example>

    <example>
     <title>Procurando o tamanho de uma vari&aacute;vel em uma tabela de s&iacute;mbolos</title>
     <programlisting role="c">
<![CDATA[
hash_find(active_symbol_table,"foo",sizeof("foo"),&pvalue);
check(pvalue.type);
]]>
     </programlisting>
    </example>
    
	Os arrays no PHP s&atilde;o executadas usando as mesmas hashtables 
	que as tabelas de s&iacute;mbolos. Isto significa que as duas 
	fun&ccedil;&otilde;es abaixo tamb&eacute;m podem ser usadas para checar 
	vari&aacute;veis dentro de arrays.</para>
    
   <simpara>
    Se voc&ecirc; quiser definir um novo array numa tabela de s&iacute;mbolos, 
	voc&ecirc; deve fazer o seguinte.
   </simpara>

   <simpara>
    Primeiro, voc&ecirc; talvez queria checar se j&aacute; n&atilde;o existe um array 
	e abort&aacute;-lo se houver, usando o hash_exists() ou hash_find().
   </simpara>

   <simpara>
    Ap&oacute;s, inicialize o array:</simpara>
    
   <para>
    <example>
     <title>Inicializando um novo array</title>
     <programlisting role="c">
<![CDATA[
pval arr;
  
if (array_init(&arr) == FAILURE) { failed... };
hash_update(active_symbol_table,"foo",sizeof("foo"),&arr,sizeof(pval),NULL);
]]>
     </programlisting>
    </example>
    
	Este c&oacute;digo declara um novo array, chamado $foo, na tabela 
	de s&iacute;mbolos ativa. Este array est&aacute; vazio.</para>
    
   <simpara>
    Aqui est&aacute; o c&oacute;digo apra adicionar novas entrads &agrave; ele:</simpara>
  
   <para>
    <example>
     <title>Adicionando novas entradas ao array</title>
     <programlisting role="c">
<![CDATA[
pval entry;
  
entry.type = IS_LONG;
entry.value.lval = 5;
  
/* defines $foo["bar"] = 5 */
hash_update(arr.value.ht,"bar",sizeof("bar"),&entry,sizeof(pval),NULL); 

/* defines $foo[7] = 5 */
hash_index_update(arr.value.ht,7,&entry,sizeof(pval),NULL); 

/* defines the next free place in $foo[],
 * $foo[8], to be 5 (works like php2)
 */
hash_next_index_insert(arr.value.ht,&entry,sizeof(pval),NULL); 
]]>
     </programlisting>
    </example>
    
	Se voc&ecirc; quiser modificar o valor que foi inserido ao hash, voc&ecirc; 
	deve primeiro peg&aacute;-lo do hash. Para previnir overhead, voc&ecirc; pode 
	suprir a pval ** da fun&ccedil;&atilde;o adicionar do hash, e isto ir&aacute; 
	atualizar com o endere&ccedil;o pval * do elemento inserido dentro 
	do hash. Se o valor for &null; (como em todos os exemplos abaixo) - 
	aquele par&acirc;metro &eacute; ignorado.</para>

   <simpara>
    hash_next_index_insert() usa mais ou menos a mesma l&oacute;gica que 
	"$foo[] = bar;" do PHP 2.0.</simpara>

   <simpara>
    Se voc&ecirc; est&aacute; construindo um array que retorna de uma fun&ccedil;&atilde;o, 
	voc&ecirc; pode inicializar o array como no exemplo abaixo:</simpara>

   <programlisting role="c">
<![CDATA[
if (array_init(return_value) == FAILURE) { failed...; }
]]>
   </programlisting>

   <simpara>
    ...e ent&atilde;o adicionar valores com as fun&ccedil;&otilde;es do helper:</simpara>

   <programlisting role="c">
<![CDATA[
add_next_index_long(return_value,long_value);
add_next_index_double(return_value,double_value);
add_next_index_string(return_value,estrdup(string_value));
]]>
   </programlisting>
  
   <para>
    Claro, se a adi&ccedil;&atilde;o n&atilde;o terminou corretamente depois da 
	inicializa&ccedil;&atilde;o do array, voc&ecirc; provavelmente dever&aacute; 
	procurar pelo array primeiro:
      
    <programlisting role="c">
<![CDATA[
pval *arr;
  
if (hash_find(active_symbol_table,"foo",sizeof("foo"),(void **)&arr)==FAILURE) { can't find... }
else { use arr->value.ht... }
]]>
    </programlisting></para>

   <simpara>
    Note que o hash_find recebe o ponteiro para um ponteiro pval, e 
	n&atilde;o um ponteiro pval.</simpara>
  
   <simpara>
    Assim como qualquer fun&ccedil;&atilde;o hash retorna SUCESSO ou FALHA (exceto 
	para o hash_exists(), que retorna um valor booleano verdadeiro).</simpara></sect2>
      
  <sect2 id="phpdevel-addfunc-retsimple">
   <title>Retornando valores simples</title>
   <simpara>
    Um n&uacute;mero de macros est&atilde;o dispon&iacute;veis para fazer o retorno de 
	valores de uma fun&ccedil;&atilde;o ser muito mais f&aacute;cil.</simpara> 

   <para>
    A macro RETURN_* ajusta todos os valores de retorno e do retorno 
	da fun&ccedil;&atilde;o:
    <itemizedlist>
     <listitem><simpara>RETURN</simpara></listitem>
     <listitem><simpara>RETURN_FALSE</simpara></listitem>
     <listitem><simpara>RETURN_TRUE</simpara></listitem>
     <listitem><simpara>RETURN_LONG(l)</simpara></listitem>
     <listitem><simpara>RETURN_STRING(s,dup)   If dup is &true;, duplicates the string</simpara></listitem>
     <listitem><simpara>RETURN_STRINGL(s,l,dup)   Return string (s) specifying length (l).</simpara></listitem>
     <listitem><simpara>RETURN_DOUBLE(d)</simpara></listitem>
    </itemizedlist></para>
    
   <para>
    The RETVAL_* macros set the return value, but do not return.
    <itemizedlist>
     <listitem><simpara>RETVAL_FALSE</simpara></listitem>
     <listitem><simpara>RETVAL_TRUE</simpara></listitem>
     <listitem><simpara>RETVAL_LONG(l)</simpara></listitem>
     <listitem><simpara>RETVAL_STRING(s,dup)   If dup is &true;, duplicates the string</simpara></listitem>
     <listitem><simpara>RETVAL_STRINGL(s,l,dup)   Return string (s) specifying length (l).</simpara></listitem>
     <listitem><simpara>RETVAL_DOUBLE(d)</simpara></listitem>
    </itemizedlist></para>

   <simpara>
	As macros de string abaixo ser&atilde;o todas estrdup() passadas para 
	's' argumento, ent&atilde;o voc&ecirc; pode seguramente liberar o argumento 
	ap&oacute;s chamar a macro, ou alternativamente usar uma mem&oacute;ria 
	est&aacute;tica alocada.</simpara>

   <simpara>
    Se sua fun&ccedil;&atilde;o retornar respostas booleanas de sucesso/erro, 
	sempre use RETURN_TRUE e RETURN_FALSE respectivamente.</simpara></sect2>
    
  <sect2 id="phpdevel-addfunc-retcomplex">
   <title>Retornando valores complexos</title>
   <simpara>
    Sua fun&ccedil;&atilde;o pode tamb&eacute;m retornar um tipo de dado complexo assim 
	como um objeto ou um array.</simpara>

   <para>
    Retornando um objeto:

    <orderedlist numeration="arabic">
     <listitem><simpara>Chamar o object_init(return_value).</simpara></listitem>
     <listitem><para>Preencher isto com valores. A fun&ccedil;&atilde;o 
	 dispon&iacute;vel para este prop&oacute;sito &eacute; listada a seguir.</para></listitem>
     <listitem><para>Possivelmente, registrar a fun&ccedil;&atilde;o para este objeto. 
	 A fim de obter os valores do objeto, a fun&ccedil;&atilde;o 
	 teria que buscar "this" do active_symbol_table. Este 
	 tipo dever&aacute; ser IS_OBJECT, e &eacute; basicamente uma tabela 
	 hash regular (i.e., voc&ecirc; pode usar fun&ccedil;&otilde;es hash nos .value.ht). 
	 O registrador atual da fun&ccedil;&atilde;o pode ser usado fazendo:
       <programlisting role="c">
<![CDATA[
add_method( return_value, function_name, function_ptr );
]]>
       </programlisting>
			 </para></listitem>
    </orderedlist></para>

   <para>
    As fun&ccedil;&otilde;es usadas para povoar um objeto:
    <itemizedlist>
     <listitem><simpara>add_property_long( return_value,
       property_name, l ) - Add a property named 'property_name', of
       type long, equal to 'l'</simpara></listitem> 
     <listitem><simpara>add_property_double( return_value,
       property_name, d ) - Same, only adds a double</simpara></listitem>
     <listitem><simpara>add_property_string( return_value,
       property_name, str ) - Same, only adds a string</simpara></listitem>
     <listitem><simpara>add_property_stringl( return_value,
       property_name, str, l ) - Same, only adds a string of length 'l'</simpara></listitem>
    </itemizedlist></para>

   <para>
    Retornando um array:
    
    <orderedlist numeration="arabic">
     <listitem><simpara>Chamar array_init(return_value).</simpara></listitem>
     <listitem><simpara>Preencher isto com valores. A fun&ccedil;&atilde;o dispon&iacute;vel 
	 para este prop&oacute;sito &eacute; listada a seguir.</simpara></listitem>
    </orderedlist></para>

   <para>
    As fun&ccedil;&otilde;es usadas para povoar um array s&atilde;o:
    <itemizedlist>
     <listitem><simpara>add_assoc_long(return_value,key,l) - add
     associative entry with key 'key' and long value 'l'</simpara></listitem>
     <listitem><simpara>add_assoc_double(return_value,key,d)</simpara></listitem>
     <listitem><simpara>add_assoc_string(return_value,key,str,duplicate)</simpara></listitem>
     <listitem><simpara>add_assoc_stringl(return_value,key,str,length,duplicate)
     specify the string length</simpara></listitem>
     <listitem><simpara>add_index_long(return_value,index,l) - add
     entry in index 'index' with long value 'l'</simpara></listitem>
     <listitem><simpara>add_index_double(return_value,index,d)</simpara></listitem>
     <listitem><simpara>add_index_string(return_value,index,str)</simpara></listitem>
     <listitem><simpara>add_index_stringl(return_value,index,str,length)
     - specify the string length</simpara></listitem>
     <listitem><simpara>add_next_index_long(return_value,l) - add an
     array entry in the next free offset with long value 'l'</simpara></listitem>
     <listitem><simpara>add_next_index_double(return_value,d)</simpara></listitem>
     <listitem><simpara>add_next_index_string(return_value,str)</simpara></listitem>
     <listitem><simpara>add_next_index_stringl(return_value,str,length)
     - specify the string length</simpara></listitem>
    </itemizedlist></para></sect2>

  <sect2 id="phpdevel-addfunc-reslist">
   <title>Usando a lista de recursos</title>
   <simpara>
    O PHP tem uma maneira padr&atilde;o de trator os v&aacute;rios tipos de 
	recursos. Isto substitui todos os local linked lists do PHP 2.0.</simpara>

   <para>
    Fun&ccedil;&otilde;es dispon&iacute;veis:

    <itemizedlist>
     <listitem><simpara>php3_list_insert(ptr, type) - returns the 'id'
       of the newly inserted resource</simpara></listitem>
     <listitem><simpara>php3_list_delete(id) - delete the resource
       with the specified id</simpara></listitem> 
     <listitem><simpara>php3_list_find(id,*type)
       - returns the pointer of the resource with the specified id,
       updates 'type' to the resource's type</simpara></listitem>
    </itemizedlist>

	Tipicamente, estas fun&ccedil;&otilde;es s&atilde;o usadas para drivers SQL mas 
	elas podem ser usadas para qualquer otura coisa; para instanciar, 
	manusear arquivos de descritores.</para>

   <simpara>
    Um c&oacute;digo t&iacute;pico &eacute; listado a seguir:</simpara>
    
   <para>
    <example>
     <title>Adicionando novos recursos</title>
     <programlisting role="c">
<![CDATA[
RESOURCE *resource;

/* ...allocate memory for resource and acquire resource... */
/* add a new resource to the list */
return_value->value.lval = php3_list_insert((void *) resource, LE_RESOURCE_TYPE);
return_value->type = IS_LONG;
]]>
     </programlisting>
    </example>

    <example>
     <title>Usando um recurso existente</title>
     <programlisting role="c">
<![CDATA[
pval *resource_id;
RESOURCE *resource;
int type;

convert_to_long(resource_id);
resource = php3_list_find(resource_id->value.lval, &type);
if (type != LE_RESOURCE_TYPE) {
	php3_error(E_WARNING,"resource index %d has the wrong type",resource_id->value.lval);
	RETURN_FALSE;
}
/* ...use resource... */
]]>
     </programlisting>
    </example>

    <example>
     <title>Deletando um recurso existente</title>
     <programlisting role="c">
<![CDATA[
pval *resource_id;
RESOURCE *resource;
int type;

convert_to_long(resource_id);
php3_list_delete(resource_id->value.lval);
]]>
     </programlisting>
    </example>

	O tipo de recurso deve ser registrado no php3_list.h, no enum
	list_entry_type. Al&eacute;m disso, um deve adicionar c&oacute;digo para 
	qualquer novo tipo de recurso definido, em list.c's list_entry_destructor() 
	(mesmo se voc&ecirc; n&atilde;o tem nada para adicionar ao shutdown, voc&ecirc; 
	deve adicionar um caso em branco).</para></sect2>

  <sect2 id="phpdevel-addfunc-prestable">
   <title>Usando o recurso persistente da tabela</title>
   <para>
    O PHP tem uma maneira padr&atilde;o de armazenar recursos persistentes (i.e., 
	recursos que s&atilde;o mantidos dentre os hits). O primeiro m&oacute;dulo &agrave; usar 
	esta caracter&iacute;stica foi o m&oacute;dulo MySQL, e mSQL seguindo-os, ent&atilde;o 
	um pode pegar uma impress&atilde;o geral de como um recurso persistente 
	deve ser usado lendo mysql.c. As fun&ccedil;&otilde;es devem se parecem com as abaixo:

    <simplelist>
     <member>php3_mysql_do_connect</member>
     <member>php3_mysql_connect()</member>
     <member>php3_mysql_pconnect()</member>
    </simplelist></para>

   <para>
    A id&eacute;ia geral dos m&oacute;dulos persistentes &eacute; esta:
    <orderedlist numeration="arabic">
     <listitem><simpara>Codifique todos os seus m&oacute;dulos para trabalhar 
	 com um recurso regular mecionados na se&ccedil;&atilde;o (9).</simpara></listitem>
     <listitem><simpara>Codifique fun&ccedil;&otilde;es extras de conex&atilde;o para checar 
	 se o recurso j&aacute; existe na lista de recursos persistentes. Se j&aacute; 
	 existir, registre ela na lista de recursos regular como um ponteiro 
	 para a lista de recursos persistentes (porque o 1., o resto do c&oacute;digo 
	 dever&aacute; funcionar imediatamente). Se ela n&atilde;o existe, ent&atilde;o crie ela, adicione-a 
	 a lista de recursos persistentes E adicione um ponteiro para ela vindo da 
	 lista de recursos regular, mas na pr&oacute;xima conex&atilde;o, o recurso 
	 ser&aacute; encontrado na lsita de recursos persitentes e ser&aacute; usado 
	 sem ter que recri&aacute;-lo. Voc&ecirc; deve registrar estes recursos 
	 com um tipo diferente (e.g. LE_MYSQL_LINK para link 
	 n&atilde;o-persistente e LE_MYSQL_PLINK para um link persistente).</simpara></listitem>
    </orderedlist></para>

   <simpara>
    Se voc&ecirc; ler o mysql.c, voc&ecirc; ir&aacute; notar que exceto pela fun&ccedil;&atilde;o 
	complexa de conex&atilde;o, nada no resto do m&oacute;dulo tem que ser mudado.</simpara>
   
   <simpara>
    A mesma rela&ccedil;&atilde;o existe para a lista de recursos regular e 
	para a lista de recursos persistentes, somente a 'list' &eacute; 
	substitu&iacute;da com 'plist':</simpara>

    <itemizedlist>
     <listitem><simpara>php3_plist_insert(ptr, type) - returns the 'id'
       of the newly inserted resource</simpara></listitem>
     <listitem><simpara>php3_plist_delete(id) - delete the resource
       with the specified id</simpara></listitem> 
     <listitem><simpara>php3_plist_find(id,*type)
       - returns the pointer of the resource with the specified id,
       updates 'type' to the resource's type</simpara></listitem>
    </itemizedlist>

   <simpara>
    Entretanto, &eacute; mais prov&aacute;vel que estas fun&ccedil;&otilde;es provariam ser 
	in&uacute;tils a n&atilde;o quando voc&ecirc; tenta implementar um m&oacute;dulo persistente. 
	Tipicamente, um seria usada de fato para a lista de recursos 
	persistentes que realmente seria uma tabela hash. Para instanciar, 
	nos m&oacute;dulos de conex&atilde;o MySQL/mSQL, quando existe uma chamada 
	pconnect() (conex&atilde;o persistente), a fun&ccedil;&atilde;o constr&oacute;i uma string fora 
	do host/usr/passwd que s&atilde;o passadas para a fun&ccedil;&atilde;o, e mistura o link 
	SQL com esta string como uma chave. Na pr&oacute;xima vez que algu&eacute;m 
	chamar a pconnect() com os mesmos host/user/passwd, a mesma chave 
	dever&aacute; ser gerada, e a fun&ccedil;&atilde;o encontraria o link SQL na 
	lista persistente.</simpara>

   <simpara>
    At&eacute; que seja feita documenta&ccedil;&atilde;o adicional, voc&ecirc; deve olhar no 
	mysql.c ou msql.c para ver como deve usar as habilidades da 
	plist's tabela de hash.</simpara>

   <simpara>
    Uma coisa importante a notar: recursos que v&atilde;o para para a lista 
	de recursos persistentes *N&Atilde;O" devem ser alocados no gerenciador 
	de mem&oacute;ria do PHP, i.e., N&Atilde;O devem ser criados com emalloc(), strdup(), etc. 
	O motivo para isto &eacute; simples - ao fim da requisi&ccedil;&atilde;o (fim do hit), 
	cada peda&ccedil;o de mem&oacute;ria que foi alocada usando o gerenciador 
	de mem&oacute;ria do PHP &eacute; deletado. Desde que a lista persistente 
	n&atilde;o &eacute; supostamente para ser deletada ao fim da requisi&ccedil;&atilde;o, 
	n&atilde;o se deve usar o gerenciador de mem&oacute;ria do PHP 
	para alocar recursos que v&atilde;o para ela.</simpara>

   <simpara>
    Quando voc&ecirc; registra um recurso que vai ficar na lista persistente, 
	voc&ecirc; deve adicionar desconstrutores em ambas as listas persistente 
	e n&atilde;o-persistente. O desconstrutor na lista n&atilde;o-persistente 
	n&atilde;o deve fazer nada. J&aacute; o que est&aacute; na lista persistente 
	deve liberar corretamente qualquer recurso obtido por este 
	tipo (e.g. mem&oacute;ria, SQL links, etc). Assim como os recursos da lista 
	n&atilde;o-persistente, voc&ecirc; *DEVE* adicionar desconstrutores para 
	qualquer recurso, mesmo os que n&atilde;o requerem desconstrutores 
	e este desconstrutor ficaria vazio. Lembre-se, desde que 
	emalloc() e seus amigos n&atilde;o est&atilde;o sendo usados em conjunto 
	com a lista persistente, voc&ecirc; n&atilde;o deve usar o efree().</simpara></sect2>


  <sect2 id="phpdevel-addfunc-addcfg">
   <title>Adicionar diretivas de configura&ccedil;&atilde;o runtime</title>
   <para>
    Muitas caracter&iacute;sticas do PHP podem ser configuradas em modo runtime. 
	Estas diretivas de configura&ccedil;&otilde;es podem aparecer no arquivo de 
	configura&ccedil;&atilde;o php3.ini, ou no caso na vers&atilde;o do m&oacute;dul para o Apache 
	nos arquivos .conf do Apache. A vantagem de t&ecirc;-las nos arquivos 
	.conf do Apache &eacute; que elas podem ser configuradas em apenas 
	um diret&oacute;rio. Isto significa que um diret&oacute;rio pode ter um certo 
	safemodeexecdir por exemplo, enquanto em outro diret&oacute;rio 
	pode ter um outro tipo de safemodeexecdir. Estas configura&ccedil;&otilde;es 
	s&atilde;o especiamente acess&iacute;veis quando um servidor suporta 
	m&uacute;ltiplos hosts virtuais.</para>

   <para>
    Os requisitos para adicionar uma diretiva:

    <orderedlist>
     <listitem><simpara>Adicione a diretiva php3_ini_structure struct em mod_php3.h.</simpara></listitem> 
    
     <listitem><simpara>No main.c, edite a fun&ccedil;&atilde;o php3_module_startup
       e adicione a chamada apropriada cfg_get_string() ou
       cfg_get_long().</simpara></listitem>

     <listitem><simpara>Adicione a diretiva, restri&ccedil;&otilde;es e coment&aacute;rios 
	 &agrave; estrutura de php3_commands em mod_php3.c. Anote as partes 
	 restritras. RSRC_CONF s&atilde;o diretivas que somente est&atilde;o presentes 
	 nos arquivos .conf do Apache. Qualquer 
	 diretiva OR_OPTIONS pode estar presente em qualquer lugar, 
	 incluindo os arquivos .htaccess.</simpara></listitem>

     <listitem><simpara>Em php3takelhandler() ou php3flaghandler() 
	 adicione a entrada apropriada para sua diretiva.</simpara></listitem>

     <listitem><simpara>Na se&ccedil;&atilde;o de configura&ccedil;&atilde;o da fun&ccedil;&atilde;o 
	 _php3_info() em functions/info.c voc&ecirc; precisa adicionar 
	 sua nova diretiva.</simpara></listitem>

     <listitem><simpara>E por &uacute;ltimo, voc&ecirc; naturalmente tem que 
	 usar sua nova diretiva em algum lugar. Ela ser&aacute; 
	 endere&ccedil;ada como php3_ini.directive.</simpara></listitem>
    </orderedlist></para></sect2></sect1>


 <sect1 id="calling-user-functions">
  <title>Chamando Fun&ccedil;&otilde;es do Usu&aacute;rio</title>

  <simpara>
   Para chamar fun&ccedil;&otilde;es do usu&aacute;rio de uma fun&ccedil;&atilde;o interna, voc&ecirc; 
   deve usar a fun&ccedil;&atilde;o <function>call_user_function</function>.
  </simpara>

  <simpara>
   <function>call_user_function</function> retorna SUCESSO no sucesso, 
   e FALHA no caso de a fun&ccedil;&atilde;o n&atilde;o ter sido encontrada. 
   Voc&ecirc; deve checar este valor de retorno! Se ela retornar SUCESSO, 
   voc&ecirc; &eacute; respons&aacute;vel por destruir a retval pval por voc&ecirc; mesmo 
   (ou retornar ela como um valor de retorno da sua fun&ccedil;&atilde;o). 
   Se ela retornar FALHA, o valor da retval &eacute; indefinido, 
   e voc&ecirc; n&atilde;o deve mexe nisto.
  </simpara>

  <simpara>
   Todas as fun&ccedil;&otilde;es internas que chama fun&ccedil;&otilde;es 
   de usu&aacute;rio <emphasis>devem</emphasis> ser reentrantes. 
   Entre outras coisas, isto significa que ela n&atilde;o deve 
   usar vari&aacute;veis globais ou est&aacute;ticas.
  </simpara>

  <simpara>
   <function>call_user_function</function> usa seis argumentos:
  </simpara>

  <sect2 id="calling-user-functions.function-table">
   <title>HashTable *function_table</title>
   <simpara>
    Esta &eacute; a tabela hash onde a fun&ccedil;&atilde;o deve ser procurada.
   </simpara></sect2>

  <sect2 id="calling-user-functions.object">
   <title>pval *object</title>
   <simpara>
    Este &eacute; o ponteiro para um objeto em que a fun&ccedil;&atilde;o &eacute; invocada. 
	Ele dever &null; se a fun&ccedil;&atilde;o global &eacute; chamada. E se ele 
	n&atilde;o &eacute; &null; (i.e. este ponteio &eacute; um objeto), o argumento 
	function_table &eacute; ignorado, ao inv&eacute;s de pegar o hash do objeto. 
	O objeto *talvez* seja modificado pela fun&ccedil;&atilde;o que &eacute; invocada 
	nele (esta fun&ccedil;&atilde;o talvez tenha acesso a ele via $this). 
	Se por alguma raz&atilde;o voc&ecirc; n&atilde;o quer que isto aconte&ccedil;a, 
	envie uma c&oacute;pia do objeto ao inv&eacute;s dele.
   </simpara></sect2>

  <sect2 id="calling-user-functions.function-name">
   <title>pval *function_name</title>
   <simpara>
    O nome da fun&ccedil;&atilde;o &agrave; ser chamada. Deve ser um pval do tipo 
	IS_STRING com function_name.str.val e function_name.str.len 
	enviando os valores apropriados. A function_name &eacute; modificada 
	por call_user_function() - que &eacute; convertido para letra min&uacute;scula. 
	Se voc&ecirc; precisa preservar caso, envie uma c&oacute;pia do 
	nome da fun&ccedil;&atilde;o ao inv&eacute;s dela.
   </simpara></sect2>

  <sect2 id="calling-user-functions.retval">
   <title>pval *retval</title>
   <simpara>
    Um ponteiro para uma estrutura do pval, onde o valor 
	retornada do a fun&ccedil;&atilde;o invocada &eacute; salvo. A estrutura deve 
	previamente alocada - <function>call_user_function</function> 
	N&Atilde;O aloque por voc&ecirc; mesmo.
   </simpara></sect2>

  <sect2 id="calling-user-functions.param-count">
   <title>int param_count</title>
   <simpara>
    O n&uacute;mero de par&acirc;metros passados &agrave; fun&ccedil;&atilde;o.
   </simpara></sect2>

  <sect2 id="calling-user-functions.params">
   <title>pval *params[]</title>
   <simpara>
    Um array de ponteiros para valores que v&atilde;o ser passados 
	como argumentos para a fun&ccedil;&atilde;o, o primeiro argumento come&ccedil;a no 
	offset 0, o segundo no offset 1, etc. O array &eacute; um array 
	de ponteiros para pval's; Os ponteiros s&atilde;o 
	enviados como-s&atilde;o para a fun&ccedil;&atilde;o, isto significa que se a fun&ccedil;&atilde;o 
	&eacute; modificada por seus argumentos, os valores originais s&atilde;o 
	alterados (passando por refer&ecirc;ncia). 
	Se voc&ecirc; n&atilde;o quer este comportamento, passe uma c&oacute;pia ao 
	inv&eacute;s do original.
   </simpara></sect2></sect1>

 <sect1 id="phpdevel-errors">
  <title>Relatando erros</title>

  <simpara>
   Para relatar erros de uma fun&ccedil;&atilde;o interna, voc&ecirc; deve chamar a 
   fun&ccedil;&atilde;o <function>php3_error</function>. Ela pega ao menos 
   dois par&acirc;metros -- o primeiro &eacute; o n&iacute;vel do erro, o segundo 
   &eacute; a string formatada para a mensagem de erro (como em uma 
   chamada padr&atilde;o <function>printf</function>), e os argumentos 
   seguintes s&atilde;o os par&acirc;metros para a string formatada. Os n&iacute;veis 
   de erro s&atilde;o:
  </simpara>

  <sect2 id="internal.e-notice">
   <title>E_NOTICE</title>
   <simpara>
    Avisos n&atilde;o s&atilde;o mostrados por padr&atilde;o, e indicam que o script 
	encontrou algo que poderia indicar um erro, mas que pode 
	tamb&eacute;m ter acontecido na execu&ccedil;&atilde;o do script. Por exemplo, 
	tentando acessar um valor de uma vari&aacute;vel que n&atilde;o foi setada, 
	ou chamando <function>stat</function> em um arquivo que n&atilde;o existe.
   </simpara>
  </sect2>

  <sect2 id="internal.e-warning">
   <title>E_WARNING</title>
   <simpara>
    Os avisos s&atilde;o mostrados por padr&atilde;o, mas n&atilde;o interrompem a 
	execu&ccedil;&atilde;o do script. Eles indicam um problema que deve ter 
	acontecido antes do script ser chamado. Por exemplo, 
	chamando <function>ereg</function> com uma express&atilde;o regular inv&aacute;lida.
   </simpara>
  </sect2>

  <sect2 id="internal.e-error">
   <title>E_ERROR</title>
   <simpara>
    Os erros tamb&eacute;m s&atilde;o mostrados por padr&atilde;o, e a execu&ccedil;&atilde;o do script &eacute; 
	interrompida ap&oacute;s a fun&ccedil;&atilde;o retornar. Ele indica erros que podem 
	n&atilde;o ser recuperados, como um problema de aloca&ccedil;&atilde;o de mem&oacute;ria.
   </simpara>
  </sect2>

  <sect2 id="internal.e-parse">
   <title>E_PARSE</title>
   <simpara>
    Erros do Parse deveriam unicamente ser gerados somente pelo parser. O c&oacute;digo &eacute; 
	listado aqui somente para a causa de integridade.
   </simpara>
  </sect2>

  <sect2 id="internal.e-core-error">
   <title>E_CORE_ERROR</title>
   <simpara>
    Este &eacute; como um E_ERROR, exceto que ele &eacute; gerado pelo n&uacute;cleo 
	do PHP. Fun&ccedil;&otilde;es n&atilde;o devem gerar este tipo de erro.
   </simpara>
  </sect2>

  <sect2 id="internal.e-core-warning">
   <title>E_CORE_WARNING</title>
   <simpara>
    Este &eacute; como um E_WARNING, exceto que ele &eacute; gerado pelo n&uacute;cleo 
	do PHP. Fun&ccedil;&otilde;es n&atilde;o devem gerar este tipo de erro.
   </simpara>
  </sect2>

  <sect2 id="internal.e-compile-error">
   <title>E_COMPILE_ERROR</title>
   <simpara>
     Este &eacute; como um E_ERROR, exceto que ele &eacute; gerado pelo Zend Scripting 
	 Engine. Fun&ccedil;&otilde;es n&atilde;o devem gerar este tipo de erro.
   </simpara>
  </sect2>

  <sect2 id="internal.e-compile-warning">
   <title>E_COMPILE_WARNING</title>
   <simpara>
     Este &eacute; como um E_WARNING, exceto que ele &eacute; gerado pelo Zend Scripting 
	 Engine. Fun&ccedil;&otilde;es n&atilde;o devem gerar este tipo de erro.
   </simpara>
  </sect2>

  <sect2 id="internal.e-user-error">
   <title>E_USER_ERROR</title>
   <simpara>
     Este &eacute; como um E_ERROR, exceto que ele &eacute; gerado no c&oacute;digo PHP 
	 usando a fun&ccedil;&atilde;o PHP <function>trigger_error</function>. 
	 Fun&ccedil;&otilde;es n&atilde;o devem gerar este tipo de erro.
   </simpara>
  </sect2>

  <sect2 id="internal.e-user-warning">
   <title>E_USER_WARNING</title>
   <simpara>
     Este &eacute; como um E_WARNING, exceto que ele &eacute; gerado no c&oacute;digo PHP 
	 usando a fun&ccedil;&atilde;o PHP <function>trigger_error</function>. 
	 Fun&ccedil;&otilde;es n&atilde;o devem gerar este tipo de erro.
   </simpara>
  </sect2>

  <sect2 id="internal.e-user-notice">
   <title>E_USER_NOTICE</title>
   <simpara>
     Este &eacute; como um E_NOTICE, exceto que ele &eacute; gerado no c&oacute;digo PHP 
	 usando a fun&ccedil;&atilde;o PHP <function>trigger_error</function>. 
	 Fun&ccedil;&otilde;es n&atilde;o devem gerar este tipo de erro.
   </simpara>
  </sect2>
  
  <sect2 id="internal.e-all">
   <title>E_ALL</title>
   <simpara>
    Todos acima. Usando este n&iacute;vel de error_reporting voc&ecirc; 
	ver&aacute; todos os tipos de erros.
   </simpara>
  </sect2>

  </sect1>
 </appendix>
<!-- Keep this comment at the end of the file
Local variables:
mode: sgml
sgml-omittag:t
sgml-shorttag:t
sgml-minimize-attributes:nil
sgml-always-quote-attributes:t
sgml-indent-step:1
sgml-indent-data:t
indent-tabs-mode:nil
sgml-parent-document:nil
sgml-default-dtd-file:"../../manual.ced"
sgml-exposed-tags:nil
sgml-local-catalogs:nil
sgml-local-ecat-files:nil
End:
vim600: syn=xml fen fdm=syntax fdl=2 si
vim: et tw=78 syn=sgml
vi: ts=1 sw=1
-->
