<?xml version="1.0" encoding="utf-8"?>
<!-- $Revision: 1.1 $ -->
  <sect1 xml:id="language.types.array">
   <title>Arrays</title>

   <para>
    An array in PHP is actually an ordered map. A map is a type that
    maps <emphasis>values</emphasis> to <emphasis>keys</emphasis>. 
    This type is optimized in several ways,
    so you can use it as a real array, or a list (vector), 
    hashtable (which is an implementation of a map), 
    dictionary, collection,
    stack, queue and probably more. Because you can have another
    PHP array as a value, you can also quite easily simulate
    trees.
   </para>
   <para>
    Explanation of those data structures is beyond the scope of this
    manual, but you'll find at least one example for each of them.
    For more information we refer you to external literature about
    this broad topic.
   </para>
   
   <sect2 xml:id="language.types.array.syntax">
    <title>Syntax</title>
    
    <sect3 xml:id="language.types.array.syntax.array-func">
     <title>Specifying with <function>array</function></title>
     <para>
      An <type>array</type> can be created by the <function>array</function> 
      language-construct. It takes a certain number of comma-separated
      <literal><replaceable>key</replaceable> =&gt; <replaceable
      >value</replaceable></literal>
      pairs.
     </para>
     <para>
      <synopsis>
array( <optional> <replaceable>key</replaceable> =&gt; </optional> <replaceable>value</replaceable>
     , ...
     )
// <replaceable>key</replaceable> may be an <type>integer</type> or <type>string</type>
// <replaceable>value</replaceable> may be any value
      </synopsis>
     </para>
     <para>
      <informalexample>
       <programlisting role="php">
<![CDATA[
<?php
$arr = array("foo" => "bar", 12 => true);

echo $arr["foo"]; // bar
echo $arr[12];    // 1
?>
]]>
       </programlisting>
      </informalexample>
     </para>
     <para>
      A <varname>key</varname> may be either an
      <type>integer</type> or a <type>string</type>. If a key is
      the standard representation of an <type>integer</type>, it will
      be interpreted as such (i.e.  <literal>"8"</literal> will be
      interpreted as <literal>8</literal>, while
      <literal>"08"</literal> will be interpreted as
      <literal>"08"</literal>).
      Floats in <varname>key</varname> are truncated to <type>integer</type>.
      There are no different indexed and
      associative array types in PHP; there is only one array type,
      which can both contain integer and string indices.
     </para>
     <para>
      A value can be of any PHP type.
      <informalexample>
       <programlisting role="php">
<![CDATA[
<?php
$arr = array("somearray" => array(6 => 5, 13 => 9, "a" => 42));

echo $arr["somearray"][6];    // 5
echo $arr["somearray"][13];   // 9
echo $arr["somearray"]["a"];  // 42
?>
]]>
       </programlisting>
      </informalexample>
     </para>
     <para>
      If you do not specify a key for a given value, then the maximum
      of the integer indices is taken, and the new key will be that
      maximum value + 1. If you specify a key that already has a value
      assigned to it, that value will be overwritten.
      <informalexample>
       <programlisting role="php">
<![CDATA[
<?php
// This array is the same as ...
array(5 => 43, 32, 56, "b" => 12);

// ...this array
array(5 => 43, 6 => 32, 7 => 56, "b" => 12);
?>
]]>
       </programlisting>
      </informalexample>
     </para>
     <warning>
      <simpara>
         As of PHP 4.3.0, the index generation behaviour described
         above has changed. Now, if you append to an array in which
         the current maximum key is negative, then the next key
         created will be zero (<literal>0</literal>). Before, the new
         index would have been set to the largest existing key + 1,
         the same as positive indices are.
      </simpara>
     </warning>
     <para>
      Using &true; as a key will evaluate to <type>integer</type>
      <literal>1</literal> as key. Using &false; as a key will evaluate
      to <type>integer</type> <literal>0</literal> as key. Using
      <literal>NULL</literal> as a key will evaluate to the empty
      string. Using the empty string as key will create (or overwrite)
      a key with the empty string and its value; it is not the same as
      using empty brackets.
     </para>
     <para>
      You cannot use arrays or objects as keys. Doing so will result in a
      warning: <literal>Illegal offset type</literal>.
     </para>
    </sect3>
    
    <sect3 xml:id="language.types.array.syntax.modifying">
     <title>Creating/modifying with square-bracket syntax</title>
     <para>
      You can also modify an existing array by explicitly setting
      values in it.
     </para>
     <para>
      This is done by assigning values to the array while specifying the 
      key in brackets. You can also omit the key, add an empty pair
      of brackets ("<literal>[]</literal>") to the variable name in that case.
      <synopsis>
$arr[<replaceable>key</replaceable>] = <replaceable>value</replaceable>;
$arr[] = <replaceable>value</replaceable>;
// <replaceable>key</replaceable> may be an <type>integer</type> or <type>string</type>
// <replaceable>value</replaceable> may be any value
      </synopsis>
      If <varname>$arr</varname> doesn't exist yet, it will be created. 
      So this is also an alternative way to specify an array.
      To change a certain value, just assign a new value
      to an element specified with its key. If you want to
      remove a key/value pair, you need to <function>unset</function> it. 
      <informalexample>
       <programlisting role="php">
<![CDATA[
<?php
$arr = array(5 => 1, 12 => 2);

$arr[] = 56;    // This is the same as $arr[13] = 56;
                // at this point of the script

$arr["x"] = 42; // This adds a new element to
                // the array with key "x"
                
unset($arr[5]); // This removes the element from the array

unset($arr);    // This deletes the whole array
?>
]]> 
       </programlisting>
      </informalexample>
     </para>
     <note>
      <para>
       As mentioned above, if you provide the brackets with no key
       specified, then the maximum of the existing integer indices is
       taken, and the new key will be that maximum value + 1 . If no
       integer indices exist yet, the key will be <literal>0</literal>
       (zero). If you specify a key that already has a value assigned
       to it, that value will be overwritten.
      </para>
      <para>
       <warning>
        <simpara>
         As of PHP 4.3.0, the index generation behaviour described
         above has changed. Now, if you append to an array in which
         the current maximum key is negative, then the next key
         created will be zero (<literal>0</literal>). Before, the new
         index would have been set to the largest existing key + 1,
         the same as positive indices are.
        </simpara>
       </warning>
      </para>
      <para>
       Note that the maximum integer key used for this <emphasis>need
       not currently exist in the array</emphasis>. It simply must
       have existed in the array at some time since the last time the
       array was re-indexed. The following example illustrates:
      </para>

      <informalexample>
       <programlisting role="php">
<![CDATA[
<?php
// Create a simple array.
$array = array(1, 2, 3, 4, 5);
print_r($array);

// Now delete every item, but leave the array itself intact:
foreach ($array as $i => $value) {
    unset($array[$i]);
}
print_r($array);

// Append an item (note that the new key is 5, instead of 0 as you
// might expect).
$array[] = 6;
print_r($array);

// Re-index:
$array = array_values($array);
$array[] = 7;
print_r($array);
?>
]]> 
       </programlisting>
       &example.outputs;
       <screen>
<![CDATA[
Array
(
    [0] => 1
    [1] => 2
    [2] => 3
    [3] => 4
    [4] => 5
)
Array
(
)
Array
(
    [5] => 6
)
Array
(
    [0] => 6
    [1] => 7
)
]]>
       </screen>
      </informalexample>       

     </note>
    </sect3>
   </sect2><!-- end syntax -->
   
   <sect2 xml:id="language.types.array.useful-funcs">
    <title>Useful functions</title>
    <para>
     There are quite a few useful functions for working with arrays.
     See the <link linkend="ref.array">array functions</link> section.
    </para>
    <note>
     <para>
      The <function>unset</function> function allows unsetting keys of an 
      array. Be aware that the array will NOT be reindexed. If you only
      use "usual integer indices" (starting from zero, increasing by one),
      you can achieve the reindex effect by using <function>array_values</function>.
      <informalexample>
       <programlisting role="php">
<![CDATA[
<?php
$a = array(1 => 'one', 2 => 'two', 3 => 'three');
unset($a[2]);
/* will produce an array that would have been defined as
   $a = array(1 => 'one', 3 => 'three');
   and NOT
   $a = array(1 => 'one', 2 =>'three');
*/

$b = array_values($a);
// Now $b is array(0 => 'one', 1 =>'three')
?>
]]>
      </programlisting>
     </informalexample>
     
     </para>    
    </note> 
    <para>
     The <link linkend="control-structures.foreach">foreach</link> 
     control structure exists specifically for arrays. It 
     provides an easy way to traverse an array.
    </para>
   </sect2>
   
   <sect2 xml:id="language.types.array.donts">
    <title>Array do's and don'ts</title>

    <sect3 xml:id="language.types.array.foo-bar">
     <title>Why is <literal>$foo[bar]</literal> wrong?</title>
     <para>
      You should always use quotes around a string literal
      array index.  For example, use $foo['bar'] and not
      $foo[bar]. But why is $foo[bar] wrong? You might have seen the
      following syntax in old scripts:
      <informalexample>
       <programlisting role="php">
<![CDATA[
<?php
$foo[bar] = 'enemy';
echo $foo[bar];
// etc
?>
]]>
       </programlisting>
      </informalexample>
      This is wrong, but it works. Then, why is it wrong? The reason
      is that this code has an undefined constant (bar) rather than a
      string ('bar' - notice the quotes), and PHP may in future define
      constants which, unfortunately for your code, have the same
      name.  It works because PHP automatically converts a
      <emphasis>bare string</emphasis> (an unquoted string which does
      not correspond to any known symbol) into a string which contains
      the bare string. For instance, if there is no defined constant
      named <constant>bar</constant>, then PHP will substitute in the
      string <literal>'bar'</literal> and use that.
     </para>
     <note>
      <simpara>
       This does not mean to <emphasis>always</emphasis> quote the
       key. You do not want to quote keys which are <link
       linkend="language.constants">constants</link> or <link
       linkend="language.variables">variables</link>, as this will
       prevent PHP from interpreting them.
      </simpara>
      <informalexample>
       <programlisting role="php">
<![CDATA[
<?php
error_reporting(E_ALL);
ini_set('display_errors', true);
ini_set('html_errors', false);
// Simple array:
$array = array(1, 2);
$count = count($array);
for ($i = 0; $i < $count; $i++) {
    echo "\nChecking $i: \n";
    echo "Bad: " . $array['$i'] . "\n";
    echo "Good: " . $array[$i] . "\n";
    echo "Bad: {$array['$i']}\n";
    echo "Good: {$array[$i]}\n";
}
?>
]]>
       </programlisting>
      </informalexample>
      &example.outputs;
      <screen>
<![CDATA[
Checking 0: 
Notice: Undefined index:  $i in /path/to/script.html on line 9
Bad: 
Good: 1
Notice: Undefined index:  $i in /path/to/script.html on line 11
Bad: 
Good: 1

Checking 1: 
Notice: Undefined index:  $i in /path/to/script.html on line 9
Bad: 
Good: 2
Notice: Undefined index:  $i in /path/to/script.html on line 11
Bad: 
Good: 2
]]>        
      </screen>
     </note>
     <para>
      More examples to demonstrate this fact:
      <informalexample>
       <programlisting role="php">
<![CDATA[
<?php
// Let's show all errors
error_reporting(E_ALL);

$arr = array('fruit' => 'apple', 'veggie' => 'carrot');

// Correct
print $arr['fruit'];  // apple
print $arr['veggie']; // carrot

// Incorrect.  This works but also throws a PHP error of
// level E_NOTICE because of an undefined constant named fruit
// 
// Notice: Use of undefined constant fruit - assumed 'fruit' in...
print $arr[fruit];    // apple

// Let's define a constant to demonstrate what's going on.  We
// will assign value 'veggie' to a constant named fruit.
define('fruit', 'veggie');

// Notice the difference now
print $arr['fruit'];  // apple
print $arr[fruit];    // carrot

// The following is okay as it's inside a string.  Constants are not
// looked for within strings so no E_NOTICE error here
print "Hello $arr[fruit]";      // Hello apple

// With one exception, braces surrounding arrays within strings
// allows constants to be looked for
print "Hello {$arr[fruit]}";    // Hello carrot
print "Hello {$arr['fruit']}";  // Hello apple

// This will not work, results in a parse error such as:
// Parse error: parse error, expecting T_STRING' or T_VARIABLE' or T_NUM_STRING'
// This of course applies to using superglobals in strings as well
print "Hello $arr['fruit']";
print "Hello $_GET['foo']";

// Concatenation is another option
print "Hello " . $arr['fruit']; // Hello apple
?>
]]>
       </programlisting>
      </informalexample>
     </para>
     <para>
      When you turn <function>error_reporting</function> up to show
      <constant>E_NOTICE</constant> level errors (such as setting
      it to <constant>E_ALL</constant>) then you will see these
      errors.  By default, <link linkend="ini.error-reporting">
      error_reporting</link> is turned down to not show them.
     </para>
     <para>
      As stated in the <link
      linkend="language.types.array.syntax">syntax</link> section,
      there must be an expression between the square brackets
      ('<literal>[</literal>' and '<literal>]</literal>').  That means
      that you can write things like this:
      <informalexample>
       <programlisting role="php">
<![CDATA[
<?php
echo $arr[somefunc($bar)];
?>
]]>
       </programlisting>
      </informalexample>
      This is an example of using a function return value
      as the array index. PHP also knows about constants,
      as you may have seen the <literal>E_*</literal> ones
      before.      

      <informalexample>
       <programlisting role="php">
<![CDATA[
<?php
$error_descriptions[E_ERROR]   = "A fatal error has occured";
$error_descriptions[E_WARNING] = "PHP issued a warning";
$error_descriptions[E_NOTICE]  = "This is just an informal notice";
?>
]]>
       </programlisting>
      </informalexample>
      Note that <literal>E_ERROR</literal> is also a valid identifier, 
      just like <literal>bar</literal> in the first example. But the last
      example is in fact the same as writing:
      <informalexample>
       <programlisting role="php">
<![CDATA[
<?php
$error_descriptions[1] = "A fatal error has occured";
$error_descriptions[2] = "PHP issued a warning";
$error_descriptions[8] = "This is just an informal notice";
?>
]]>
       </programlisting>
      </informalexample>
      because <literal>E_ERROR</literal> equals <literal>1</literal>, etc.
     </para>
     <para>
      As we already explained in the above examples, 
      <literal>$foo[bar]</literal> still works but is wrong.
      It works, because <literal>bar</literal> is due to its syntax
      expected to be a constant expression. However, in this case no 
      constant with the name <literal>bar</literal> exists. PHP now
      assumes that you meant <literal>bar</literal> literally, 
      as the string <literal>"bar"</literal>, but that you forgot
      to write the quotes.
     </para>
     <sect4 xml:id="language.types.array.foo-bar.why">
      <title>So why is it bad then?</title>
      <para>
       At some point in the future, the PHP team might want to add another
       constant or keyword, or you may introduce another constant into your
       application, and then you get in trouble. For example,
       you already cannot use the words <literal>empty</literal> and 
       <literal>default</literal> this way, since they are special 
       <link linkend="reserved">reserved keywords</link>.
      </para>
      <note>
       <simpara>
        To reiterate, inside a double-quoted <type>string</type>, it's
        valid to not surround array indexes with quotes so
        <literal>"$foo[bar]"</literal> is valid.  See the above 
        examples for details on why as well as the section on
        <link linkend="language.types.string.parsing">variable parsing 
        in strings</link>.
       </simpara>
      </note>
     </sect4>
    </sect3>
   </sect2>

   <sect2 xml:id="language.types.array.casting">
    <title>Converting to array</title>
    
    <para>
     For any of the types: <type>integer</type>, <type>float</type>,
     <type>string</type>, <type>boolean</type> and <type>resource</type>,
     if you convert a value to an <type>array</type>, you get an array 
     with one element (with index 0), which is the scalar value you 
     started with.
    </para>
    
    <para>
     If you convert an <type>object</type> to an array, you get the
     properties (member variables) of that object as the array's elements. 
     The keys are the member variable names with a few notable exceptions:
      private variables have the class name prepended to the variable name;
      protected variables have a '*' prepended to the variable name.
     These prepended values have null bytes on either side. This can result
     in some unexpected behaviour.
      <informalexample>
       <programlisting role="php">
<![CDATA[
<?php

class A {
    private $A; // This will become '\0A\0A'
}

class B extends A {
    private $A; // This will become '\0B\0A'
    public $AA; // This will become 'AA'
}

var_dump((array) new B());
?>
]]>
       </programlisting>
      </informalexample>

     The above will appear to have two keys named 'AA', although one
     of them is actually named '\0A\0A'.
    </para>
    
    <para>
     If you convert a &null; value to an array, you get an empty array.
    </para>
   </sect2>

   <sect2 xml:id="language.types.array.comparing">
    <title>Comparing</title>
    <para>
     It is possible to compare arrays by <function>array_diff</function> and
     by <link linkend="language.operators.array">Array operators</link>.
    </para>
   </sect2>

   <sect2 xml:id="language.types.array.examples">
    <title>Examples</title>
    <para>
     The array type in PHP is very versatile, so here will be some 
     examples to show you the full power of arrays.
    </para>
    <para>
      <informalexample>
       <programlisting role="php">
<![CDATA[
<?php
// this
$a = array( 'color' => 'red',
            'taste' => 'sweet',
            'shape' => 'round',
            'name'  => 'apple',
                       4        // key will be 0
          );

// is completely equivalent with
$a['color'] = 'red';
$a['taste'] = 'sweet';
$a['shape'] = 'round';
$a['name']  = 'apple';
$a[]        = 4;        // key will be 0

$b[] = 'a';
$b[] = 'b';
$b[] = 'c';
// will result in the array array(0 => 'a' , 1 => 'b' , 2 => 'c'),
// or simply array('a', 'b', 'c')
?>
]]>
       </programlisting>
      </informalexample>
     </para>
    
    <example>
     <title>Using array()</title>
     <programlisting role="php">
<![CDATA[
<?php
// Array as (property-)map
$map = array( 'version'    => 4,
              'OS'         => 'Linux',
              'lang'       => 'english',
              'short_tags' => true
            );
            
// strictly numerical keys
$array = array( 7,
                8,
                0,
                156,
                -10
              );
// this is the same as array(0 => 7, 1 => 8, ...)

$switching = array(         10, // key = 0
                    5    =>  6,
                    3    =>  7, 
                    'a'  =>  4,
                            11, // key = 6 (maximum of integer-indices was 5)
                    '8'  =>  2, // key = 8 (integer!)
                    '02' => 77, // key = '02'
                    0    => 12  // the value 10 will be overwritten by 12
                  );
                  
// empty array
$empty = array();         
?>
]]>
<!-- TODO example of
- overwriting keys
- using vars/functions as key/values
- warning about references
-->
     </programlisting>
    </example>

    <example xml:id="language.types.array.examples.loop">
     <title>Collection</title>
     <programlisting role="php">
<![CDATA[
<?php
$colors = array('red', 'blue', 'green', 'yellow');

foreach ($colors as $color) {
    echo "Do you like $color?\n";
}

?>
]]>
     </programlisting>
     &example.outputs;
     <screen>
<![CDATA[
Do you like red?
Do you like blue?
Do you like green?
Do you like yellow?
]]>
     </screen>
    </example>
    
    <para>
     Changing values of the array directly is possible since PHP 5 by passing
     them as reference. Prior versions need workaround:
     <example xml:id="language.types.array.examples.changeloop">
      <title>Collection</title>
      <programlisting role="php">
<![CDATA[
<?php
// PHP 5
foreach ($colors as &$color) {
    $color = strtoupper($color);
}
unset($color); /* ensure that following writes to
$color will not modify the last array element */

// Workaround for older versions
foreach ($colors as $key => $color) {
    $colors[$key] = strtoupper($color);
}

print_r($colors);
?>
]]>
      </programlisting>
      &example.outputs;
      <screen>
<![CDATA[
Array
(
    [0] => RED
    [1] => BLUE
    [2] => GREEN
    [3] => YELLOW
)
]]>
      </screen>
     </example>
    </para>
    <para>
     This example creates a one-based array.
     <example>
      <title>One-based index</title>
      <programlisting role="php">
<![CDATA[
<?php
$firstquarter  = array(1 => 'January', 'February', 'March');
print_r($firstquarter);
?>
]]>
      </programlisting>
      &example.outputs;
      <screen>
<![CDATA[
Array 
(
    [1] => 'January'
    [2] => 'February'
    [3] => 'March'
)
]]>   
      </screen>
     </example>
    </para>
    <example>
     <title>Filling an array</title>
     <programlisting role="php">
<![CDATA[
<?php
// fill an array with all items from a directory
$handle = opendir('.');
while (false !== ($file = readdir($handle))) {
    $files[] = $file;
}
closedir($handle); 
?>
]]>
     </programlisting>
    </example>
    <para>
     Arrays are ordered. You can also change the order using various
     sorting functions. See the <link linkend="ref.array">array
     functions</link> section for more information. You can count
     the number of items in an array using the
     <function>count</function> function.
    </para>
    <example>
     <title>Sorting an array</title>
     <programlisting role="php">
<![CDATA[
<?php
sort($files);
print_r($files);
?>
]]>
     </programlisting>
    </example>
    <para>
     Because the value of an array can be anything, it can also be
     another array. This way you can make recursive and
     multi-dimensional arrays.
    </para>
    <example>
     <title>Recursive and multi-dimensional arrays</title>
     <programlisting role="php">
<![CDATA[
<?php
$fruits = array ( "fruits"  => array ( "a" => "orange",
                                       "b" => "banana",
                                       "c" => "apple"
                                     ),
                  "numbers" => array ( 1,
                                       2,
                                       3,
                                       4,
                                       5,
                                       6
                                     ),
                  "holes"   => array (      "first",
                                       5 => "second",
                                            "third"
                                     )
                );

// Some examples to address values in the array above 
echo $fruits["holes"][5];    // prints "second"
echo $fruits["fruits"]["a"]; // prints "orange"
unset($fruits["holes"][0]);  // remove "first"

// Create a new multi-dimensional array
$juices["apple"]["green"] = "good"; 
?>
]]>
     </programlisting>
    </example>
    <para>
     You should be aware that array assignment always involves
     value copying. It also means that the internal array pointer used by
     <function>current</function> and similar functions is reset.
     You need to use the reference operator to copy
     an array by reference.
     <informalexample>
      <programlisting role="php">
<![CDATA[
<?php
$arr1 = array(2, 3);
$arr2 = $arr1;
$arr2[] = 4; // $arr2 is changed,
             // $arr1 is still array(2, 3)
             
$arr3 = &$arr1;
$arr3[] = 4; // now $arr1 and $arr3 are the same
?>
]]>
      </programlisting>
     </informalexample>
    </para>
   </sect2>
  </sect1>

<!-- Keep this comment at the end of the file
Local variables:
mode: sgml
sgml-omittag:t
sgml-shorttag:t
sgml-minimize-attributes:nil
sgml-always-quote-attributes:t
sgml-indent-step:1
sgml-indent-data:t
indent-tabs-mode:nil
sgml-parent-document:nil
sgml-default-dtd-file:"../../manual.ced"
sgml-exposed-tags:nil
sgml-local-catalogs:nil
sgml-local-ecat-files:nil
End:
vim600: syn=xml fen fdm=syntax fdl=2 si
vim: et tw=78 syn=sgml
vi: ts=1 sw=1
-->
