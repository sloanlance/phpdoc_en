<?xml version="1.0" encoding="utf-8"?>
<!-- $Revision: 1.4 $ -->
<sect1 xml:id="language.types.string">
 <title>Strings</title>

 <para>
  A <type>string</type> is series of characters. In PHP, a character is the same
  as a byte, that is, there are exactly 256 different characters possible. This
  also implies that PHP has no native support of Unicode. See
  <function>utf8_encode</function> and <function>utf8_decode</function> for some
  Unicode support.
 </para>

 <note>
  <simpara>
   It is no problem for a string to become very large. There is no practical
   bound to the size of strings imposed by PHP, so there is no reason at all to
   worry about long strings.
  </simpara>
 </note>

 <sect2 xml:id="language.types.string.syntax">
  <title>Syntax</title>

  <para>
   A string literal can be specified in three different ways.
  </para>

  <itemizedlist>
   <listitem>
    <simpara>
     <link linkend="language.types.string.syntax.single">single quoted</link>
    </simpara>
   </listitem>
   <listitem>
    <simpara>
     <link linkend="language.types.string.syntax.double">double quoted</link>
    </simpara>
   </listitem>
   <listitem>
    <simpara>
     <link linkend="language.types.string.syntax.heredoc">heredoc syntax</link>
    </simpara>
   </listitem>
  </itemizedlist>

  <sect3 xml:id="language.types.string.syntax.single">
   <title>Single quoted</title>

   <para>
    The easiest way to specify a simple string is to enclose it in single quotes
    (the character <literal>'</literal>). 
   </para>

   <para>
    To specify a literal single quote, you will need to escape it with a
    backslash (<literal>\</literal>), like in many other languages. If a
    backslash needs to occur before a single quote or at the end of the string,
    you need to double it. Note that if you try to escape any other character,
    the backslash will also be printed! So usually there is no need to escape
    the backslash itself.
   </para>

   <note>
    <simpara>
     Unlike the two other syntaxes,
     <link linkend="language.variables">variables</link> and escape sequences
     for special characters will <emphasis>not</emphasis> be expanded when they
     occur in single quoted strings.
    </simpara>
   </note>

   <informalexample>
    <programlisting role="php">
<![CDATA[
<?php
echo 'this is a simple string';

echo 'You can also have embedded newlines in 
strings this way as it is
okay to do';

// Outputs: Arnold once said: "I'll be back"
echo 'Arnold once said: "I\'ll be back"';

// Outputs: You deleted C:\*.*?
echo 'You deleted C:\\*.*?';

// Outputs: You deleted C:\*.*?
echo 'You deleted C:\*.*?';

// Outputs: This will not expand: \n a newline
echo 'This will not expand: \n a newline';

// Outputs: Variables do not $expand $either
echo 'Variables do not $expand $either';
?>
]]>
    </programlisting>
   </informalexample>

  </sect3>

  <sect3 xml:id="language.types.string.syntax.double">
   <title>Double quoted</title>

   <para>
    If the string is enclosed in double-quotes ("), PHP understands more escape
    sequences for special characters:
   </para>

   <table>
    <title>Escaped characters</title>

    <tgroup cols="2">
     <thead>
      <row>
       <entry>sequence</entry>
       <entry>meaning</entry>
      </row>
     </thead>

     <tbody>
      <row>
       <entry><literal>\n</literal></entry>
       <entry>linefeed (LF or 0x0A (10) in ASCII)</entry>
      </row>
      <row>
       <entry><literal>\r</literal></entry>
       <entry>carriage return (CR or 0x0D (13) in ASCII)</entry>
      </row>
      <row>
       <entry><literal>\t</literal></entry>
       <entry>horizontal tab (HT or 0x09 (9) in ASCII)</entry>
      </row>
      <row>
       <entry><literal>\v</literal></entry>
       <entry>vertical tab (VT or 0x0B (11) in ASCII) (since PHP 5.2.5)</entry>
      </row>
      <row>
       <entry><literal>\f</literal></entry>
       <entry>form feed (FF or 0x0C (12) in ASCII) (since PHP 5.2.5)</entry>
      </row>
      <row>
       <entry><literal>\\</literal></entry>
       <entry>backslash</entry>
      </row>
      <row>
       <entry><literal>\$</literal></entry>
       <entry>dollar sign</entry>
      </row>
      <row>
       <entry><literal>\"</literal></entry>
       <entry>double-quote</entry>
      </row>
      <row>
       <entry><literal>\[0-7]{1,3}</literal></entry>
       <entry>
        the sequence of characters matching the regular expression is a
        character in octal notation
       </entry>
      </row>
      <row>
       <entry><literal>\x[0-9A-Fa-f]{1,2}</literal></entry>
       <entry>
        the sequence of characters matching the regular expression is a
        character in hexadecimal notation
       </entry>
      </row>
     </tbody>
    </tgroup>
   </table>

   <para>
    Again, if you try to escape any other character, the backslash will be
    printed too! Before PHP 5.1.1, backslash in <literal>\{$var}</literal>
    hasn't been printed.
   </para>

   <para>
    But the most important feature of double-quoted strings is the fact that
    variable names will be expanded. See
    <link linkend="language.types.string.parsing">string parsing</link> for
    details.
   </para>
  </sect3>
  
  <sect3 xml:id="language.types.string.syntax.heredoc">
   <title>Heredoc</title>

   <simpara>
    Another way to delimit strings is by using heredoc syntax ("&lt;&lt;&lt;").
    One should provide an identifier (followed by new line) after
    <literal>&lt;&lt;&lt;</literal>, then the string, and then the same
    identifier to close the quotation. 
   </simpara>

   <simpara>
    The closing identifier <emphasis>must</emphasis> begin in the first column
    of the line. Also, the identifier used must follow the same naming rules as
    any other label in PHP: it must contain only alphanumeric characters and
    underscores, and must start with a non-digit character or underscore.
   </simpara>
   
   <warning>
    <simpara>
     It is very important to note that the line with the closing identifier
     contains no other characters, except <emphasis>possibly</emphasis> a
     semicolon (<literal>;</literal>). That means especially that the identifier
     <emphasis>may not be indented</emphasis>, and there may not be any spaces
     or tabs after or before the semicolon. It's also important to realize that
     the first character before the closing identifier must be a newline as
     defined by your operating system. This is <literal>\r</literal> on
     Macintosh for example. Closing delimiter (possibly followed by a semicolon)
     must be followed by a newline too.
    </simpara>

    <simpara>
     If this rule is broken and the closing identifier is not "clean" then it's
     not considered to be a closing identifier and PHP will continue looking for
     one. If in this case a proper closing  identifier is not found then a parse
     error will result with the line number being at the end of the script.
    </simpara>

    <para>
     It is not allowed to use heredoc syntax in initializing class members. Use
     other string syntaxes instead.
    </para>

    <example>
     <title>Invalid example</title>
     <programlisting role="php">
<![CDATA[
<?php
class foo {
    public $bar = <<<EOT
bar
EOT;
}
?>
]]>
     </programlisting>
    </example>
   </warning>

   <para>
    Heredoc text behaves just like a double-quoted string, without the
    double-quotes. This means that you do not need to escape quotes in your here
    docs, but you can still use the escape codes listed above. Variables are
    expanded, but the same care must be taken when expressing complex variables
    inside a heredoc as with strings.
   </para>

   <example> 
    <title>Heredoc string quoting example</title>
    <programlisting role="php">
<![CDATA[
<?php
$str = <<<EOD
Example of string
spanning multiple lines
using heredoc syntax.
EOD;

/* More complex example, with variables. */
class foo
{
    var $foo;
    var $bar;

    function foo()
    {
        $this->foo = 'Foo';
        $this->bar = array('Bar1', 'Bar2', 'Bar3');
    }
}

$foo = new foo();
$name = 'MyName';

echo <<<EOT
My name is "$name". I am printing some $foo->foo.
Now, I am printing some {$foo->bar[1]}.
This should print a capital 'A': \x41
EOT;
?>
]]>
    </programlisting>
   </example>

   <note>
    <para>
     Heredoc support was added in PHP 4.
    </para>
   </note>
  </sect3>

  <sect3 xml:id="language.types.string.parsing">
   <title>Variable parsing</title>

   <simpara>
    When a string is specified in double quotes or with heredoc,
    <link linkend="language.variables">variables</link> are parsed within it. 
   </simpara>

   <simpara>
    There are two types of syntax: a
    <link linkend="language.types.string.parsing.simple">simple</link> one and a 
    <link linkend="language.types.string.parsing.complex">complex</link> one.
    The simple syntax is the most common and convenient. It provides a way to
    parse a variable, an <type>array</type> value, or an <type>object</type>
    property.
   </simpara>

   <simpara>
    The complex syntax was introduced in PHP 4, and can be recognised by the
    curly braces surrounding the expression.
   </simpara>

   <sect4 xml:id="language.types.string.parsing.simple">
    <title>Simple syntax</title>

    <simpara>
     If a dollar sign (<literal>$</literal>) is encountered, the parser will
     greedily take as many tokens as possible to form a valid variable name.
     Enclose the variable name in curly braces if you want to explicitly specify
     the end of the name.
    </simpara>

    <informalexample>
     <programlisting role="php">
<![CDATA[
<?php
$beer = 'Heineken';
echo "$beer's taste is great"; // works, "'" is an invalid character for varnames
echo "He drank some $beers";   // won't work, 's' is a valid character for varnames
echo "He drank some ${beer}s"; // works
echo "He drank some {$beer}s"; // works
?>
]]>
     </programlisting>
    </informalexample>

    <simpara>
     Similarly, you can also have an <type>array</type> index or an
     <type>object</type> property parsed. With array indices, the closing square
     bracket (<literal>]</literal>) marks the end of the index. For object
     properties the same rules apply as to simple variables, though with object
     properties there doesn't exist a trick like the one with variables.
     
     <!-- XXX isn't &true; :(, this would be the trick
     Also, the same trick with curly-braces works if you
     want to limit the greediness of parsers.
     -->
    </simpara>

    <informalexample>
     <programlisting role="php">
<![CDATA[
<?php
// These examples are specific to using arrays inside of strings.
// When outside of a string, always quote your array string keys 
// and do not use {braces} when outside of strings either.

// Let's show all errors
error_reporting(E_ALL);

$fruits = array('strawberry' => 'red', 'banana' => 'yellow');

// Works but note that this works differently outside string-quotes
echo "A banana is $fruits[banana].";

// Works
echo "A banana is {$fruits['banana']}.";

// Works but PHP looks for a constant named banana first
// as described below.
echo "A banana is {$fruits[banana]}.";

// Won't work, use braces.  This results in a parse error.
echo "A banana is $fruits['banana'].";

// Works
echo "A banana is " . $fruits['banana'] . ".";

// Works
echo "This square is $square->width meters broad.";

// Won't work. For a solution, see the complex syntax.
echo "This square is $square->width00 centimeters broad.";
?>
]]>
<!-- XXX this won't work:
echo "This square is $square->{width}00 centimeters broad."; 
// XXX: php developers: it would be consequent to make this work.
// XXX: like the $obj->{expr} syntax outside a string works, 
// XXX: analogously to the ${expr} syntax for variable var's.
-->
     </programlisting>
    </informalexample>

    <simpara>
     For anything more complex, you should use the complex syntax.
    </simpara>
   </sect4>

   <sect4 xml:id="language.types.string.parsing.complex">
    <title>Complex (curly) syntax</title>

    <simpara>
     This isn't called complex because the syntax is complex, but because you
     can include complex expressions this way.
    </simpara>

    <simpara>
     In fact, you can include any value that is in the namespace in strings with
     this syntax. You simply write the expression the same way as you would
     outside the string, and then include it in { and }. Since you can't escape
     '{', this syntax will only be recognised when the $ is immediately
     following the {. (Use "{\$" to get a literal "{$"). Some examples to make
     it clear:
    </simpara>

    <informalexample>
     <programlisting role="php">
<![CDATA[
<?php
// Let's show all errors
error_reporting(E_ALL);

$great = 'fantastic';

// Won't work, outputs: This is { fantastic}
echo "This is { $great}";

// Works, outputs: This is fantastic
echo "This is {$great}";
echo "This is ${great}";

// Works
echo "This square is {$square->width}00 centimeters broad."; 

// Works
echo "This works: {$arr[4][3]}";

// This is wrong for the same reason as $foo[bar] is wrong 
// outside a string.  In other words, it will still work but
// because PHP first looks for a constant named foo, it will
// throw an error of level E_NOTICE (undefined constant).
echo "This is wrong: {$arr[foo][3]}"; 

// Works.  When using multi-dimensional arrays, always use
// braces around arrays when inside of strings
echo "This works: {$arr['foo'][3]}";

// Works.
echo "This works: " . $arr['foo'][3];

echo "You can even write {$obj->values[3]->name}";

echo "This is the value of the var named $name: {${$name}}";

echo "This is the value of the var named by the return value of getName(): {${getName()}}";

echo "This is the value of the var named by the return value of \$object->getName(): {${$object->getName()}}";
?>
]]>
<!-- maybe it's better to leave this out?? 
// this works, but i disencourage its use, since this is NOT 
// involving functions, rather than mere variables, arrays and objects.
$beer = 'Heineken';
echo "I'd like to have another {${ strrev('reeb') }}, hips";
 -->
     </programlisting>
    </informalexample>
    
    <note>
     <para>
      Functions and method calls inside <literal>{$ }</literal> work since PHP 5.
     </para>
    </note>

    <note>
     <para>
      Parsing variables within strings uses more memory than string
      concatenation. When writing a PHP script in which memory usage is a
      concern, consider using the concatenation operator (.) rather than
      variable parsing.
     </para>
    </note>

   </sect4>
  </sect3>
  
  <sect3 xml:id="language.types.string.substr">
   <title>String access and modification by character</title>

   <para>
    Characters within strings may be accessed and modified by specifying the
    zero-based offset of the desired character after the string using square
    array-brackets like <varname>$str[42]</varname> so think of a string as an
    <type>array</type> of characters.
   </para>

   <note>
    <simpara>
     They may also be accessed using braces like <varname>$str{42}</varname> for
     the same purpose. However, using square array-brackets is preferred because
     the {braces} style is deprecated as of PHP 6.
    </simpara>
   </note>

   <example>
    <title>Some string examples</title>
    <programlisting role="php">
<![CDATA[
<?php
// Get the first character of a string
$str = 'This is a test.';
$first = $str[0];

// Get the third character of a string
$third = $str[2];

// Get the last character of a string.
$str = 'This is still a test.';
$last = $str[strlen($str)-1]; 

// Modify the last character of a string
$str = 'Look at the sea';
$str[strlen($str)-1] = 'e';

// Alternative method using {} is deprecated as of PHP 6
$third = $str{2};

?>
]]>
    </programlisting>
   </example>

   <note>
    <para>
     Accessing by <literal>[]</literal> or <literal>{}</literal> to
     variables of other type silently returns &null;.
    </para>
   </note>

  </sect3>
 </sect2><!-- end syntax -->

 <sect2 xml:id="language.types.string.useful-funcs">
  <title>Useful functions and operators</title>

  <para>
   Strings may be concatenated using the '.' (dot) operator. Note that the '+'
   (addition) operator will not work for this. Please see
   <link linkend="language.operators.string">String operators</link> for more
   information.
  </para>

  <para>
   There are a lot of useful functions for string modification.
  </para>

  <simpara>
   See the <link linkend="ref.strings">string functions section</link> for
   general functions, the regular expression functions for advanced find &amp;
   replacing (in two tastes: <link linkend="ref.pcre">Perl</link> and 
   <link linkend="ref.regex">POSIX extended</link>).
  </simpara>

  <simpara>
   There are also <link linkend="ref.url">functions for URL-strings</link>, and
   functions to encrypt/decrypt strings
   (<link linkend="ref.mcrypt">mcrypt</link> and
   <link linkend="ref.mhash">mhash</link>).
  </simpara>

  <simpara>
   Finally, if you still didn't find what you're looking for, see also the
   <link linkend="ref.ctype">character type functions</link>.
  </simpara>
 </sect2>

 <sect2 xml:id="language.types.string.casting">
  <title>Converting to string</title>
  
  <para>
   You can convert a value to a string using the <literal>(string)</literal>
   cast, or the <function>strval</function> function. String conversion is
   automatically done in the scope of an expression for you where a string is
   needed. This happens when you use the <function>echo</function> or
   <function>print</function> functions, or when you compare a variable value to
   a string.  Reading the manual sections on
   <link linkend="language.types">Types</link> and
   <link linkend="language.types.type-juggling">Type Juggling</link> will make
   the following clearer. See also <function>settype</function>.
  </para>
  
  <para>
   A <type>boolean</type> &true; value is converted to the string
   <literal>"1"</literal>, the &false; value is represented as
   <literal>""</literal> (empty string). This way you can convert back and forth
   between boolean and string values.
  </para>

  <para> 
   An <type>integer</type> or a floating point number (<type>float</type>) is
   converted to a string representing the number with its digits (including the
   exponent part for floating point numbers). Floating point numbers can be
   converted using the exponential notation (<literal>4.1E+6</literal>).
  </para>

  <note>
   <para>
    The decimal point character is defined in the script's locale (category
    LC_NUMERIC). See <function>setlocale</function>.
   </para>
  </note>

  <para>
   Arrays are always converted to the string <literal>"Array"</literal>, so you
   cannot dump out the contents of an <type>array</type> with
   <function>echo</function> or <function>print</function> to see what is inside
   them.  To view one element, you'd do something like
   <literal>echo $arr['foo']</literal>.  See below for tips on dumping/viewing
   the entire contents.
  </para>

  <para>
   Objects in PHP 4 are always converted to the string
   <literal>"Object"</literal>. If you would like to print out the member
   variable values of an <type>object</type> for debugging reasons, read the
   paragraphs below. If you would like to find out the class name of which an
   object is an instance of, use <function>get_class</function>. As of PHP 5,
   __toString() method is used if applicable.
  </para>

  <para>
   Resources are always converted to strings with the structure
   <literal>"Resource id #1"</literal> where <literal>1</literal> is the unique
   number of the <type>resource</type> assigned by PHP during runtime. If you
   would like to get the type of the resource, use
   <function>get_resource_type</function>.
  </para>

  <para>
   &null; is always converted to an empty string.
  </para>
  
  <para>
   As you can see above, printing out the arrays, objects or resources does not
   provide you any useful information about the values themselves. Look at the
   functions <function>print_r</function> and <function>var_dump</function> for
   better ways to print out values for debugging.
  </para>
  
  <para>
   You can also convert PHP values to strings to store them permanently. This
   method is called serialization, and can be done with the function
   <function>serialize</function>. You can also serialize PHP values to XML
   structures, if you have <link linkend="ref.wddx">WDDX</link> support in your
   PHP setup.
  </para>
 </sect2>

 <sect2 xml:id="language.types.string.conversion">
  <title>String conversion to numbers</title>

  <simpara>
   When a string is evaluated as a numeric value, the resulting value and type
   are determined as follows.
  </simpara>

  <simpara>
   The string will evaluate as a <type>float</type> if it contains any of the
   characters '.', 'e', or 'E'. Otherwise, it will evaluate as an integer.
  </simpara>

  <para>
   The value is given by the initial portion of the string. If the string starts
   with valid numeric data, this will be the value used. Otherwise, the value
   will be 0 (zero). Valid numeric data is an optional sign, followed by one or
   more digits (optionally containing a decimal point), followed by an optional
   exponent. The exponent is an 'e' or 'E' followed by one or more digits.
  </para>

  <informalexample>
   <programlisting role="php">
<![CDATA[
<?php
$foo = 1 + "10.5";                // $foo is float (11.5)
$foo = 1 + "-1.3e3";              // $foo is float (-1299)
$foo = 1 + "bob-1.3e3";           // $foo is integer (1)
$foo = 1 + "bob3";                // $foo is integer (1)
$foo = 1 + "10 Small Pigs";       // $foo is integer (11)
$foo = 4 + "10.2 Little Piggies"; // $foo is float (14.2)
$foo = "10.0 pigs " + 1;          // $foo is float (11)
$foo = "10.0 pigs " + 1.0;        // $foo is float (11)     
?>
]]>
   </programlisting>
  </informalexample>

  <simpara>
   For more information on this conversion, see the Unix manual page for
   strtod(3).
  </simpara>

  <para>
   If you would like to test any of the examples in this section, you can cut
   and paste the examples and insert the following line to see for yourself
   what's going on:
  </para>

  <informalexample>
   <programlisting role="php">
<![CDATA[
<?php
echo "\$foo==$foo; type is " . gettype ($foo) . "<br />\n";
?>
]]>
   </programlisting>
  </informalexample>

  <para>
   Do not expect to get the code of one character by converting it to integer
   (as you would do in C for example). Use the functions
   <function>ord</function> and <function>chr</function> to convert between
   charcodes and characters.
  </para>

 </sect2>
</sect1><!-- end string -->
 
<!-- Keep this comment at the end of the file
Local variables:
mode: sgml
sgml-omittag:t
sgml-shorttag:t
sgml-minimize-attributes:nil
sgml-always-quote-attributes:t
sgml-indent-step:1
sgml-indent-data:t
indent-tabs-mode:nil
sgml-parent-document:nil
sgml-default-dtd-file:"../../manual.ced"
sgml-exposed-tags:nil
sgml-local-catalogs:nil
sgml-local-ecat-files:nil
End:
vim600: syn=xml fen fdm=syntax fdl=2 si
vim: et tw=78 syn=sgml
vi: ts=1 sw=1
-->
