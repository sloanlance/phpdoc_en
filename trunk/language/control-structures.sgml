  <chapter id="control-structures">
   <title>Control Structures</title>

   <simpara>
    Any PHP script is built out of a series of statements. A statement can
    be an assignment, a function call, a loop, a conditional statement of
    even a statement that does nothing (an empty statement). Statements
    usually end with a semicolon. In addition, statements can be grouped
    into a statement-group by encapsulating a group of statements with
    curly braces. A statement-group is a statement by itself as well. The
    various statement types are described in this chapter.

   <sect1 id="control-structures.if">
    <title><literal>if</literal></title>
 
    <para>
     The <literal>if</literal> construct is one of the most important
     features of many languages, PHP included.  It allows for conditional
     execution of code fragments.  PHP features an <literal>if</literal>
     structure that is similar to that of C:

     <informalexample><programlisting>
 if (expr)
     statement
 </programlisting></informalexample>
 
    <simpara>
     As described in the section about expressions, expr is evaluated
     to its truth value.  If <replaceable>expr</replaceable> evaluates
     to <literal>TRUE</literal>, PHP will execute statement, and if it
     evaluates to <literal>FALSE</literal> - it'll ignore it.
 
    <para>
     The following example would display <computeroutput>a is bigger
     than b</computeroutput> if <replaceable>$a</replaceable> is bigger
     than <replaceable>$b</replaceable>:
 
     <informalexample><programlisting>
 if ($a > $b)
     print "a is bigger than b";
 </programlisting></informalexample>

    <para>
     Often you'd want to have more than one statement to be executed
     conditionally.  Of course, there's no need to wrap each statement
     with an <literal>if</literal> clause.  Instead, you can group
     several statements into a statement group.
     For example, this code would display <computeroutput>a is bigger than
     b</computeroutput> if <replaceable>$a</replaceable> is bigger than
     <replaceable>$b</replaceable>, and would then assign the value of
     <replaceable>$a</replaceable> into <replaceable>$b</replaceable>:
 
     <informalexample><programlisting>
 if ($a > $b) {
     print "a is bigger than b";
     $b = $a;
 }
 </programlisting></informalexample>
 
    <simpara>
     If statements can be nested indefinitely within other
     <literal>if</literal> statements, which provides you with complete
     flexibility for conditional execution of the various parts of
     your program.
 
  <sect1 id="control-structures.else">
    <title><literal>else</literal></title>

    <para>
     Often you'd want to execute a statement if a certain condition
     is met, and a different statement if the condition is not met.
     This is what <literal>else</literal> is for.  <literal>else</literal>
     extends an <literal>if</literal> statement to execute a statement
     in case the expression in the <literal>if</literal> statement
     evaluates to <literal>FALSE</literal>.  For example, the following
     code would display <computeroutput>a is bigger than b</computeroutput>
     if <replaceable>$a</replaceable> is bigger than <replaceable>$b</replaceable>,
     and <computeroutput>a is NOT bigger than b</computeroutput> otherwise:

     <informalexample>
      <programlisting>
 if ($a > $b) {
     print "a is bigger than b";
 } else {
     print "a is NOT bigger than b";
 }
      </programlisting>
     </informalexample>
 
     The <literal>else</literal> statement is only executed
     if the <literal>if</literal> expression evaluated to
     <literal>FALSE</literal>, and if there were any <literal>elseif</literal>
     expressions - only if they evaluated to <literal>FALSE</literal>
     as well (see below).
 
   <sect1 id="control-structures.elseif">
    <title><literal>elseif</literal></title>
 
    <para>
     <literal>elseif</literal>, as its name suggests, is a combination
     of <literal>if</literal> and <literal>else</literal>.  Like
     <literal>else</literal>, it extends an <literal>if</literal>
     statement to execute a different statement in case the
     original <literal>if</literal> expression evaluates to
     <literal>FALSE</literal>.  However, unlike <literal>else</literal>,
     it will execute that alternative expression only if the
     <literal>elseif</literal> conditional expression evaluates to
     <literal>TRUE</literal>.  For example, the following code would
     display <computeroutput>a is bigger than b</computeroutput>,
     <computeroutput>a equal to b</computeroutput> or <computeroutput>a
     is smaller than b</computeroutput>:
 
     <informalexample>
      <programlisting>
 if ($a > $b) {
     print "a is bigger than b";
 } elseif ($a == $b) {
     print "a is equal to b";
 } else {
     print "a is smaller than b";
 }
      </programlisting>
     </informalexample>
 
    <simpara>
     There may be several <literal>elseif</literal>s within the same
     <literal>if</literal> statement.  The first <literal>elseif</literal>
     expression (if any) that evaluates to <literal>true</literal>
     would be executed.  In PHP, you can also write 'else if' (in two
     words) and the behavior would be identical to the one of 'elseif'
     (in a single word).  The syntactic meaning is slightly different
     (if you're familiar with C, this is the same behavior) but the
     bottom line is that both would result in exactly the same behavior.
     
    <simpara>
     The <literal>elseif</literal> statement is only executed if the preceding
     <literal>if</literal> expression and any
     preceding <literal>elseif</literal> expressions evaluated to <literal>FALSE</literal>, and the current
     <literal>elseif</literal> expression evaluated to <literal>TRUE</literal>.
 
    <sect1 id="control-structures.alternative-syntax">
     <title>Alternative syntax for <literal>if</literal> structures: <literal>if(): ... endif;</literal></title>
 
     <para>
      PHP offers a different way to group statements within an
      <literal>if</literal> statement.  This is most commonly used when
      you nest HTML blocks inside <literal>if</literal> statements, but
      can be used anywhere.  Instead of using curly braces, <literal>if
      (<replaceable>expr</replaceable>)</literal> should be followed
      by a colon, the list of one or more statements, and end with
      <literal>endif;</literal>.  Consider the following example:
 
      <informalexample>
       <programlisting>
 &lt;?php if ($a==5): ?&gt;
 A = 5
 &lt;?php endif; ?&gt;
       </programlisting>
      </informalexample>
 
     <simpara>
      In the above example, the HTML block "A = 5" is nested within an
      <literal>if</literal> statement written in the alternative syntax.
      The HTML block would be displayed only if $a is equal to 5.
 
     <para>
      The alternative syntax applies to <literal>else</literal>
      and <literal>elseif</literal> as well.  The following is an
      <literal>if</literal> structure with <literal>elseif</literal>
      and <literal>else</literal> in the alternative format:
      
      <informalexample>
       <programlisting>
 if ($a == 5):
     print "a equals 5";
     print "...";
 elseif ($a == 6):
     print "a equals 6";
     print "!!!";
 else:
     print "a is neither 5 nor 6";
 endif;
       </programlisting>
      </informalexample>
 
   <sect1 id="control-structures.while">
    <title><literal>while</literal></title>
 
    <para>
     <literal>while</literal> loops are the simplest type of loop in PHP.
     They behave just like their C counterparts.  The basic form of a
     <literal>while</literal> statement is:
 
     <informalexample>
      <programlisting>
 while (expr) statement
      </programlisting>
     </informalexample>
 
    <simpara>
     The meaning of a <literal>while</literal> statement is simple.
     It tells PHP to execute the nested statement(s) repeatedly,
     as long as the <literal>while</literal> expression evaluates
     to <literal>TRUE</literal>.  The value of the expression is
     checked each time at the beginning of the loop, so even if this
     value changes during the execution of the nested statement(s),
     execution will not stop until the end of the iteration (each
     time PHP runs the statements in the loop is one iteration).
     Sometimes, if the <literal>while</literal> expression evaluates
     to <literal>FALSE</literal> from the very beginning, the nested
     statement(s) won't even be run once.
 
    <para>
     Like with the <literal>if</literal> statement, you can group
     multiple statements within the same <literal>while</literal> loop
     by surrounding a group of statements with curly braces, or by using
     the alternate syntax:
 
     <informalexample>
      <programlisting>
     while (expr): statement ... endwhile;
 </programlisting></informalexample>
 
     <para>
      The following examples are identical, and both print numbers from
      1 to 10:
 
     <informalexample>
      <programlisting>
 /* example 1 */
 
 $i = 1;
 while ($i <= 10) {
     print $i++;  /* the printed value would be
                     $i before the increment
                     (post-increment) */
 }
 
 /* example 2 */
 
 $i = 1;
 while ($i <= 10):
     print $i;
     $i++;
 endwhile;
      </programlisting>
     </informalexample>
 
 
   <sect1 id="control-structures.do.while">
    <title><literal>do..while</literal></title>
 
    <simpara>
     <literal>do..while</literal> loops are very similar to
     <literal>while</literal> loops, except the truth expression is
     checked at the end of each iteration instead of in the beginning.
     The main difference from regular <literal>while</literal> loops
     is that the first iteration of a <literal>do..while</literal>
     loop is guarenteed to run (the truth expression is only checked
     at the end of the iteration), whereas it's may not necessarily run
     with a regular <literal>while</literal> loop (the truth expression
     is checked at the beginning of each iteration, if it evaluates
     to <literal>FALSE</literal> right from the beginning, the loop
     execution would end immediately).

    <para>
     There is just one syntax for <literal>do..while</literal> loops:
 
     <informalexample>
      <programlisting>
 $i = 0;
 do {
     print $i;
 } while ($i>0);
      </programlisting>
     </informalexample>
 
    <simpara>
     The above loop would run one time exactly, since after the first
     iteration, when truth expression is checked, it evaluates to
     <literal>FALSE</literal> ($i is not bigger than 0) and the loop
     execution ends.
 
    <para>
     Advanced C users may be familiar with a different usage of
     the <literal>do..while</literal> loop, to allow stopping
     execution in the middle of code blocks, by encapsulating
     them with <literal>do..while</literal>(0), and using the <link
     linkend="control-structures.break"><literal>break</literal></link> statement.
     The following code fragment demonstrates this:
 
     <informalexample>
      <programlisting>
 do {
     if ($i < 5) {
         print "i is not big enough";
         break;
     }
     $i *= $factor;
     if ($i < $minimum_limit) {
         break;
     }
     print "i is ok";
     ...process i...
 } while(0);
      </programlisting>
     </informalexample>
 
    <simpara>
     Don't worry if you don't understand this right away or at all.
     You can code scripts and even powerful scripts without using this
     `feature'.
 
   <sect1 id="control-structures.for">
    <title><literal>for</literal></title>
 
    <para>
     <literal>for</literal> loops are the most complex loops in
     PHP.  They behave like their C counterparts.  The syntax of a
     <literal>for</literal> loop is:
 
     <informalexample>
      <programlisting>
for (expr1; expr2; expr3) statement
      </programlisting>
     </informalexample>
 
    <simpara>
     The first expression (<replaceable>expr1</replaceable>) is evaluated
     (executed) once unconditionally at the beginning of the loop.
 
    <simpara>
     In the beginning of each iteration, <replaceable>expr2</replaceable>
     is evaluated.  If it evaluates to <literal>TRUE</literal>, the
     loop continues and the nested statement(s) are executed.  If it
     evaluates to <literal>FALSE</literal>, the execution of the loop ends.
 
    <simpara>
     At the end of each iteration, <replaceable>expr3</replaceable>
     is evaluated (executed).

    <simpara>
     Each of the expressions can be empty.
     <replaceable>expr2</replaceable> being empty means
     the loop should be run indefinitely (PHP implicitly
     considers it as <literal>TRUE</literal>, like C).
     This may not be as useless as you might think, since
     often you'd want to end the loop using a conditional <link
     linkend="control-structures.break"><literal>break</literal></link> statement
     instead of using the <literal>for</literal> truth expression.
 
    <para>
     Consider the following examples.  All of them display numbers from
     1 to 10:
 
     <informalexample>
      <programlisting>
 /* example 1 */
 
 for ($i = 1; $i <= 10; $i++) {
     print $i;
 }
 
 /* example 2 */
 
 for ($i = 1;;$i++) {
     if ($i > 10) {
         break;
     }
     print $i;
 }
 
 /* example 3 */
 
 $i = 1;
 for (;;) {
     if ($i > 10) {
         break;
     }
     print $i;
     $i++;
 }
 
 /* example 4 */
 
 for ($i = 1; $i <= 10; print $i, $i++) ;
      </programlisting>
     </informalexample>
 
    <simpara>
     Of course, the first example appears to be the nicest one (or
     perhaps the fourth), but you may find that being able to use empty
     expressions in <literal>for</literal> loops comes in handy in
     many occasions.
 
    <para>
     PHP also supports the alternate "colon syntax" for
     <literal>for</literal> loops.
 
     <informalexample>
      <programlisting>
 for (expr1; expr2; expr3): statement; ...; endfor;
      </programlisting>
     </informalexample>
 
    <para>
     Other languages have a foreach statement to traverse an array or
     hash. PHP uses the while statement and the <function>list</function>
     and <function>each</function> functions for this. See the
     documentation for these functions for an example.
 
 
   <sect1 id="control-structures.break">
    <title><literal>break</literal></title>
 
    <para>
     <literal>break</literal> breaks out of the current looping control-structures.
 
     <informalexample>
      <programlisting>
 $i = 0;
 while ($i < 10) {
     if ($arr[$i] == "stop") {
         break;
     }
     $i++;
 }
      </programlisting>
     </informalexample>
 
   <sect1 id="control-structures.continue">
    <title><literal>continue</literal></title>
 
    <para>
     <literal>continue</literal> is used within looping structures to
     skip the rest of the current loop iteration and continue
     execution at the beginning of the next iteration.
 
     <informalexample>
      <programlisting>
 while (list($key,$value) = each($arr)) {
     if ($key % 2) { // skip even members
         continue;
     }
     do_something_odd ($value);
 }
      </programlisting>
     </informalexample>
 
   <sect1 id="control-structures.switch">
    <title><literal>switch</literal></title>
 
    <simpara>
     The <literal>switch</literal> statement is similar to a series
     of IF statements on the same expression.  In many occasions,
     you may want to compare the same variable (or expression) with
     many different values, and execute a different piece of code
     depending on which value it equals to.  This is exactly what the
     <literal>switch</literal> statement is for.
 
    <para>
     The following two examples are two different ways to write the
     same thing, one using a series of <literal>if</literal> statements,
     and the other using the <literal>switch</literal> statement:
 
     <informalexample>
      <programlisting>
 /* example 1 */
 
 if ($i == 0) {
     print "i equals 0";
 }
 if ($i == 1) {
     print "i equals 1";
 }
 if ($i == 2) {
     print "i equals 2";
 }
 
 /* example 2 */
 
 switch ($i) {
     case 0:
         print "i equals 0";
         break;
     case 1:
         print "i equals 1";
         break;
     case 2:
         print "i equals 2";
         break;
 }
      </programlisting>
     </informalexample>
 
    <para>
     It is important to understand how the <literal>switch</literal>
     statement is executed in order to avoid messups.  The
     <literal>switch</literal> statement executes line by line (actually,
     statement by statement).  In the beginning, no code is executed.
     Only when a <literal>case</literal> statement is found with a value that matches the
     value of the <literal>switch</literal> expression, PHP begins to
     execute the statements.  PHP continues to execute the statements
     until the end of the <literal>switch</literal> block, or the first
     time it sees a <literal>break</literal> statement.  If you don't
     write a <literal>break</literal> statement at the end of a case's
     statement list, PHP will go on executing the statements of the
     following case.  For example:
 
     <informalexample>
      <programlisting>
 /* example 3 */
 
 switch ($i) {
     case 0:
         print "i equals 0";
     case 1:
         print "i equals 1";
     case 2:
         print "i equals 2";
 }
      </programlisting>
     </informalexample>
 
    <simpara>
     Here, if $i equals to 0, PHP would execute all of the print
     statements!  If $i equals to 1, PHP would execute the last
     two print statements, and only if $i equals to 2, you'd get the
     'expected' behavior and only 'i equals 2' would be displayed.  So,
     it's important not to forget <literal>break</literal> statements
     (even though you may want to avoid supplying them on purpose under
     certain circumstances).
 
    <para>
     A special case is the default case.  This case matches anything
     that wasn't matched by the other cases.  For example:
 
     <informalexample>
      <programlisting>
 /* example 4 */
 
 switch ($i) {
     case 0:
         print "i equals 0";
         break;
     case 1:
         print "i equals 1";
         break;
     case 2:
         print "i equals 2";
         break;
     default:
         print "i is not equal to 0, 1 or 2";
 }
      </programlisting>
     </informalexample>
 
    <para>
     Another fact worth mentioning is that the <literal>case</literal>
     expression may be any expression that evaluates to a scalar type,
     that is, integer or floating-point numbers and strings.  Arrays or
     objects are meaningless in that context.
 
   <sect1 id="function.require">
    <title><literal>require</literal></title>
 
    <simpara>
     The <literal>require</literal> statement replaces itself with the
     specified file, much like the C preprocessor's #include works.

    <para>
     This means that you can't put a <literal>require</literal>
     statement inside of a loop structure and expect it to include the
     contents of a different file on each iteration. To do that, use an
     <literal>include</literal> statement.
 
     <informalexample>
      <programlisting>
 require 'header.inc';
      </programlisting>
     </informalexample>
 
   <sect1 id="function.include">
    <title><literal>include</literal></title>
 
    <simpara>
     The <literal>include</literal> statement includes and evaluates
     the specified file.
 
    <para>
     This happens each time the <literal>include</literal> statement is
     encountered, so you can use an <literal>include</literal> statement
     within a looping structure to include a number of different file.
 
     <informalexample>
      <programlisting>
 $files = array ('first.inc', 'second.inc', 'third.inc');
 for ($i = 0; $i < count($files); $i++) {
     include $files[$i];
 }
      </programlisting>
     </informalexample>

    <para>
     <link linkend="function.include"><literal>include</literal></link>
     differs from <link
     linkend="function.require"><literal>require</literal></link>
     in that the include statement is re-evaluated each time it is
     encountered (and only when it is being executed), whereas the
     <link linkend="function.require"><literal>require</literal></link>
     statement is replaced by the required file when it is first
     encountered, whether the contents of the file will be evaluated or
     not (for example, if it is inside an if statement whose condition
     evaluated to false).
 
    <para>
     Because <link
     linkend="function.include"><literal>include</literal></link> is a
     special language construct, you must enclose it within a statement
     block if it is inside a conditional block.
 
     <informalexample>
      <programlisting>
 /* This is WRONG and will not work as desired. */
 
 if ($condition)
     include($file);
 else
     include($other);
 
 /* This is CORRECT. */
 
 if ($condition) {
     include($file);
 } else {
     include($other);
 }
      </programlisting>
     </informalexample>
 
    <para>
     When the file is evaluated, the parser begins in "HTML-mode" which
     will output the contents of the file until the first PHP start tag
     (&lt;?)  is encountered.

    <para>
     See also <function>readfile</function>, <function>require</function>,
     <function>virtual</function>.
 
   <sect1 id="keyword.class">
    <title><literal>class</literal></title>
    <para>
     A class is a collection of variables and functions working with
     these variables.  A class is defined using the following syntax:
 
     <informalexample>
      <programlisting role=php>
 &lt;?php
 class Cart {
     var $items;  // Items in our shopping cart
   
     // Add $num articles of $artnr to the cart
 
     function add_item ($artnr, $num) {
         $this->items[$artnr] += $num;
     }
   
     // Take $num articles of $artnr out of the cart
 
     function remove_item ($artnr, $num) {
         if ($this->items[$artnr] > $num) {
             $this->items[$artnr] -= $num;
             return true;
         } else {
             return false;
         }   
     }
 }
 ?>
      </programlisting>
     </informalexample>
 
    <para>
     This defines a class named Cart that consists of an associative
     array of articles in the cart and two functions to add and remove
     items from this cart.
 
    </para><para>
     Classes are types, that is, they are blueprints for actual
     variables. You have to create a variables of the desired type with
     the new operator.
    </para>
 
    <informalexample>
     <programlisting role=php>
 $cart = new Cart;
 $cart->add_item("10", 1);
     </programlisting>
    </informalexample>
 
    <para>
     This creates an object $cart of the class Cart. The function
     add_item() of that object is being called to add 1 item of article
     number 10 to the cart.
    </para><para>
     Classes can be extensions of other classes. The extended or
     derived class has all variables and functions of the base class
     and what you add in the extended definition.  This is done using
     the extends keyword.
    </para>
 
    <informalexample>
     <programlisting role=php>
 class Named_Cart extends Cart {
     var $owner;
  
     function set_owner ($name) {
         $this->owner = $name;
     }
 }
     </programlisting>
    </informalexample>
 
    <para>
     This defines a class Named_Cart that has all variables and
     functions of Cart plus an additional variable $owner and an
     additional function set_owner(). You create a named cart the usual
     way and can now set and get the carts owner. You can still use
     normal cart functions on named carts:
    </para>
 
    <informalexample>
     <programlisting role=php>
 $ncart = new Named_Cart;    // Create a named cart
 $ncart->set_owner ("kris"); // Name that cart
 print $ncart->owner;        // print the cart owners name
 $ncart->add_item ("10", 1); // (inherited functionality from cart)
     </programlisting>
    </informalexample>
  
    <para>
     Within functions of a class the variable $this means this
     object. You have to use $this->something to access any variable or
     function named something within your current object.
    </para>
 
    <para>
     Constructors are functions in a class that are automatically 
     called when you create a new instance of a class. A function 
     becomes a constructor when it has the same name as the class.
    </para>
 
    <informalexample>
     <programlisting role=php>
 class Auto_Cart extends Cart {
     function Auto_Cart () {
         $this->add_item ("10", 1);
     }
 }
     </programlisting>
    </informalexample>
 
    <para>
     This defines a class Auto_Cart that is a Cart plus a constructor
     which initializes the cart with one item of article number "10"
     each time a new Auto_Cart is being made with "new". Constructors
     can also take arguments and these arguments can be optional, which
     makes them much more useful.
    </para>
 
    <informalexample>
     <programlisting role=php>
 class Constructor_Cart {
     function Constructor_Cart ($item = "10", $num = 1) {
         $this->add_item ($item, $num);
     }
 }
 
 // Shop the same old boring stuff.
 
 $default_cart   = new Constructor_Cart;
 
 // Shop for real...
 
 $different_cart = new Constructor_Cart ("20", 17);
     </programlisting>
    </informalexample>
 
    <caution>
     <simpara>
      For derived classes, the constructor of the parent class is not
      automatically called when the derived class's constructor is called.
    </caution>
 
  </chapter>
 
 <!-- Keep this comment at the end of the file
 Local variables:
 mode: sgml
 sgml-omittag:t
 sgml-shorttag:t
 sgml-minimize-attributes:nil
 sgml-always-quote-attributes:t
 sgml-indent-step:1
 sgml-indent-data:t
 sgml-parent-document:nil
 sgml-default-dtd-file:"../manual.ced"
 sgml-exposed-tags:nil
 sgml-local-catalogs:nil
 sgml-local-ecat-files:nil
 End:
 -->
