 <chapter id="language.oop">
  <title>Classes and Objects</title>

  <sect1 id="keyword.class">
   <title><literal>class</literal></title>
   <para>
    A class is a collection of variables and functions working with
    these variables.  A class is defined using the following syntax:
 
    <informalexample>
     <programlisting role="php">
&lt;?php
class Cart {
    var $items;  // Items in our shopping cart
   
    // Add $num articles of $artnr to the cart
 
    function add_item ($artnr, $num) {
        $this->items[$artnr] += $num;
    }
   
    // Take $num articles of $artnr out of the cart
 
    function remove_item ($artnr, $num) {
        if ($this->items[$artnr] > $num) {
            $this->items[$artnr] -= $num;
            return true;
        } else {
            return false;
        }   
    }
}
?&gt;
     </programlisting>
    </informalexample>
   </para>
 
   <para>
    This defines a class named Cart that consists of an associative
    array of articles in the cart and two functions to add and remove
    items from this cart.
   </para>

   <note>
    <simpara>
     In PHP 4, only constant initializers for <literal>var</literal>
     variables are allowed. Use constructors for non-constant
     initializers.  
    </simpara>
    <informalexample>
     <programlisting role="php">
/* None of these will work in PHP 4. */
class Cart {
    var $todays_date = date("Y-m-d");
    var $name = $firstname;
    var $owner = 'Fred ' . 'Jones';
}

/* This is how it should be done. */
class Cart {
    var $todays_date;
    var $name;
    var $owner;

    function Cart() {
        $this->todays_date = date("Y-m-d");
        $this->name = $GLOBALS['firstname'];
        /* etc. . . */
    }
}
     </programlisting>
    </informalexample>
   </note>

   <para>
    Classes are types, that is, they are blueprints for actual
    variables. You have to create a variable of the desired type with
    the new operator.
   </para>
 
   <informalexample>
    <programlisting role="php">
$cart = new Cart;
$cart->add_item("10", 1);
    </programlisting>
   </informalexample>
 
   <para>
    This creates an object $cart of the class Cart. The function
    add_item() of that object is being called to add 1 item of article
    number 10 to the cart.  </para><para> Classes can be extensions of
    other classes. The extended or derived class has all variables and
    functions of the base class and what you add in the extended
    definition.  This is done using the extends keyword. Multiple
    inheritance is not supported.
   </para>
 
   <informalexample>
    <programlisting role="php">
class Named_Cart extends Cart {
    var $owner;
  
    function set_owner ($name) {
        $this->owner = $name;
    }
}
    </programlisting>
   </informalexample>
 
   <para>
    This defines a class Named_Cart that has all variables and
    functions of Cart plus an additional variable $owner and an
    additional function set_owner(). You create a named cart the usual
    way and can now set and get the carts owner. You can still use
    normal cart functions on named carts:
   </para>
 
   <informalexample>
    <programlisting role="php">
$ncart = new Named_Cart;    // Create a named cart
$ncart->set_owner ("kris"); // Name that cart
print $ncart->owner;        // print the cart owners name
$ncart->add_item ("10", 1); // (inherited functionality from cart)
    </programlisting>
   </informalexample>
  
   <para>
    Within functions of a class the variable $this means this
    object. You have to use $this->something to access any variable or
    function named something within your current object.  Both in and
    outside of the object you do not need a $ when accessing an object's
    properties.
   </para>

   <informalexample>
    <programlisting role="php">
$ncart->owner  = "chris"; // no $

$ncart->$owner = "chris";
// this is invalid because $ncart->$owner = $ncart->""

$myvar = 'owner';
$ncart->$myvar = "chris";  
// this is valid because $ncart->$myvar = $ncart->owner
    </programlisting>
   </informalexample>

   <para>
    Constructors are functions in a class that are automatically
    called when you create a new instance of a class. A function
    becomes a constructor when it has the same name as the class.
   </para>
 
   <informalexample>
    <programlisting role="php">
class Auto_Cart extends Cart {
    function Auto_Cart () {
        $this->add_item ("10", 1);
    }
}
    </programlisting>
   </informalexample>
 
   <para>
    This defines a class Auto_Cart that is a Cart plus a constructor
    which initializes the cart with one item of article number "10"
    each time a new Auto_Cart is being made with "new". Constructors
    can also take arguments and these arguments can be optional, which
    makes them much more useful.
   </para>
 
   <informalexample>
    <programlisting role="php">
class Constructor_Cart extends Cart {
    function Constructor_Cart ($item = "10", $num = 1) {
        $this->add_item ($item, $num);
    }
}
 
// Shop the same old boring stuff.
 
$default_cart   = new Constructor_Cart;
 
// Shop for real...
 
$different_cart = new Constructor_Cart ("20", 17);
    </programlisting>
   </informalexample>
 
   <caution>
    <simpara>
     For derived classes, the constructor of the parent class is not
     automatically called when the derived class's constructor is
     called.
    </simpara> 
   </caution>
  </sect1>
  
 <sect1 id="language.oop.newref">
   <title>References inside the constructor</title>
   <para>
    Creating references within the constructor can lead to confusing
    results. This tutorial-like section helps you to avoid problems.
 
    <informalexample>
     <programlisting role="php">

class foo {
    function foo($name) {
        // create a reference inside the global array $globalref
        global $globalref;
		$globalref[] = &amp;$this;
        // set name to passed value
        $this->setName($name);
		// and put it out
        $this->echoName();
    }

    function echoName() {
        echo "&lt;br&gt;",$this->Name;
    }
	
	function setName($name)	{
		$this->Name = $name;
    }
}
    </programlisting>
   </informalexample>
  </para>
    
   <para>
   Let us check out if there is a difference between <varname>$bar1</varname> which has been created using the copy <literal>=</literal> operator
   and <varname>$bar2</varname> which has been created using the reference <literal>=&amp;</literal> operator...
   

    <informalexample>
     <programlisting role="php">
   
    $bar1 = new foo('set in constructor');
    $bar1->echoName();
    $globalref[0]->echoName();
    
    /* output:
    set in constructor
    set in constructor
    set in constructor */
    
    $bar2 =&amp; new foo('set in constructor');
    $bar2->echoName();
    $globalref[1]->echoName();

    /* output:
    set in constructor
    set in constructor
    set in constructor */
    
        </programlisting>
   </informalexample>
  </para>
   <para>
    Apparently there is no difference, but in fact there is a very significant one:
    <varname>$bar1</varname> and <varname>$globalref[0]</varname> are _NOT_ referenced, they are NOT the same variable. 
    This is because "new" does not return a reference by default, instead it returns a copy.
       <note>
         <simpara>
         There is no performance loss (since php 4 and up use reference counting) returning copies instead of references.
         On the contrary it is most often better to simply work with copies instead of references, because creating
         references takes some time where creating copies virtually takes no time (unless none of them is a large array or object
         and one of them gets changed and the other(s) one(s) subsequently, then it would be wise to use references to change them
         all concurrently).
         </simpara>
        </note>
    To prove what is written above let us watch the code below.
   

   <informalexample>
     <programlisting role="php">
        // now we will change the name. what do you expect?
        // you could expect that both $bar and $globalref[0] change their names...
        $bar1->setName('set from outside');

        // as mentioned before this is not the case.
        $bar1->echoName();
        $globalref[0]->echoName();

        /* output:
        set on object creation
        set from outside */

        // let us see what is different with $bar2 and $globalref[1]
        $bar2->setName('set from outside');

        // luckily they are not only equyl, they are thesame variable
        // thus $bar2->Name and $globalref[1]->Name are the same too
        $bar2->echoName();
        $globalref[1]->echoName();

        /* output:
        set from outside
        set from outside */
        
      </programlisting>
   </informalexample>   
 </para>   
   <para>
   Another final example, try to understand it.
   
   <informalexample>
     <programlisting role="php">

class a {
    function a($i) {
        $this->value = $i;
        // try to figure out why we do not need a reference here
        $this->b = new b($this);
    }

    function createRef() {
        $this->c = new b($this);
    }

    function echoValue() {
        echo "&lt;br&gt;","class ",get_class($this),': ',$this->value;
        }
}


class b  {

    function b(&amp;$a) {
        $this->a = &amp;$a;
    }

   function echoValue() {
        echo "&lt;br&gt;","class ",get_class($this),': ',$this->a->value;
        }

}

// try to undestand why using a simple copy here would yield
// in an undesired result in the *-marked line
$a =&amp; new a(10);
$a->createRef();

$a->echoValue();
$a->b->echoValue();
$a->c->echoValue();

$a->value = 11;

$a->echoValue();
$a->b->echoValue(); // *
$a->c->echoValue();

/*
output:
class a: 10
class b: 10
class b: 10
class a: 11
class b: 11
class b: 11
*/
      </programlisting>
   </informalexample>
  </para>
</sect1>

 
 </chapter>
 
 <!-- Keep this comment at the end of the file
 Local variables:
 mode: sgml
 sgml-omittag:t
 sgml-shorttag:t
 sgml-minimize-attributes:nil
 sgml-always-quote-attributes:t
 sgml-indent-step:1
 sgml-indent-data:t
 sgml-parent-document:nil
 sgml-default-dtd-file:"../../manual.ced"
 sgml-exposed-tags:nil
 sgml-local-catalogs:nil
 sgml-local-ecat-files:nil
 End:
 -->
