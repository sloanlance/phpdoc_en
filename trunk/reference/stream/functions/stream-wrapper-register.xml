<?xml version="1.0" encoding="iso-8859-1"?>
<!-- $Revision: 1.20 $ -->
<refentry xml:id="function.stream-wrapper-register" xmlns="http://docbook.org/ns/docbook">
 <refnamediv>
  <refname>stream_wrapper_register</refname>
  <refpurpose>Register a URL wrapper implemented as a PHP class</refpurpose>
 </refnamediv>
 <refsect1 role="description"><!-- {{{ -->
  &reftitle.description;
  <methodsynopsis>
   <type>bool</type><methodname>stream_wrapper_register</methodname>
   <methodparam><type>string</type><parameter>protocol</parameter></methodparam>
   <methodparam><type>string</type><parameter>classname</parameter></methodparam>
  </methodsynopsis>
  <para>
   Allows you to implement your own protocol handlers and streams for use
   with all the other filesystem functions (such as <function>fopen</function>,
   <function>fread</function> etc.).
  </para>
 </refsect1><!-- }}} -->

 <refsect1 role="parameters">
  &reftitle.parameters;
  <para>
   <variablelist>
    <varlistentry>
     <term><parameter>protocol</parameter></term>
     <listitem>
      <para>
       The wrapper name to be registered.
      </para>
     </listitem>
    </varlistentry>
    <varlistentry>
     <term><parameter>classname</parameter></term>
     <listitem>
      <para>
       To implement a wrapper, you need to define a class with a number of
       member functions, as defined below. When someone fopens your stream,
       PHP will create an instance of <parameter>classname</parameter> and
       then call methods on that instance.  You must implement the methods
       exactly as described below - doing otherwise will lead to undefined
       behaviour.
      </para>
    
      <methodsynopsis>
       <type>string</type><methodname>stream_read</methodname>
       <methodparam><type>int</type><parameter>count</parameter></methodparam>
      </methodsynopsis>
      <para>
       This method is called in response to <function>fread</function>
       and <function>fgets</function> calls on the stream.  You
       must return up-to <parameter>count</parameter> bytes of data
       from the current read/write position as a string.
       If there are less than <parameter>count</parameter>
       bytes available, return as many as are available.  If no
       more data is available, return either &false; or an
       empty string.
       You must also update the read/write position of the stream
       by the number of bytes that were successfully read.
      </para>
    
      <methodsynopsis>
       <type>int</type><methodname>stream_write</methodname>
       <methodparam><type>string</type><parameter>data</parameter></methodparam>
      </methodsynopsis>
      <para>
       This method is called in response to <function>fwrite</function>
       calls on the stream.  You should store <parameter>data</parameter>
       into the underlying storage used by your stream.  If there is not
       enough room, try to store as many bytes as possible.
       You should return the number of bytes that were successfully
       stored in the stream, or 0 if none could be stored.
       You must also update the read/write position of the stream
       by the number of bytes that were successfully written.
      </para>
    
      <methodsynopsis>
       <type>int</type><methodname>stream_tell</methodname>
       <void/>
      </methodsynopsis>
      <para>
       This method is called in response to <function>ftell</function>
       calls on the stream.  You should return the current read/write
       position of the stream.
      </para>
    
      <methodsynopsis>
       <type>bool</type><methodname>stream_seek</methodname>
       <methodparam><type>int</type><parameter>offset</parameter></methodparam>
       <methodparam><type>int</type><parameter>whence</parameter></methodparam>
      </methodsynopsis>
      <para>
       This method is called in response to <function>fseek</function>
       calls on the stream.  You should update the read/write position
       of the stream according to <parameter>offset</parameter> and
       <parameter>whence</parameter>.  See <function>fseek</function>
       for more information about these parameters.
       Return &true; if the position was updated, &false; otherwise.
      </para>
    
      <methodsynopsis>
       <type>bool</type><methodname>stream_set_option</methodname>
       <methodparam><type>int</type><parameter>option</parameter></methodparam>
       <methodparam><type>int</type><parameter>arg1</parameter></methodparam>
       <methodparam><type>int</type><parameter>arg2</parameter></methodparam>
      </methodsynopsis>
      <para>
       This method is called to set options on the stream. Possible values
       for <parameter>option</parameter> are:
       <simplelist>
        <member><constant>STREAM_OPTION_BLOCKING</constant>: The method is called
         in response to <function>stream_set_blocking</function>.
         <parameter>arg1</parameter> is the requested blocking mode.</member>
        <member><constant>STREAM_OPTION_READ_TIMEOUT</constant>: The method is
         called in response to <function>stream_set_timeout</function>.
         <parameter>arg1</parameter> is the timeout in seconds, and
         <parameter>arg2</parameter> is the timeout in microseconds.</member>
        <member><constant>STREAM_OPTION_WRITE_BUFFER</constant>: The method is
         called in response to <function>stream_set_write_buffer</function>.
         <parameter>arg1</parameter> is the buffer mode
         (<constant>STREAM_BUFFER_NONE</constant> or
         <constant>STREAM_BUFFER_FULL</constant>) and <parameter>arg2</parameter>
         is the requested buffer size.</member>
       </simplelist>
      </para>
      <para>
       <function>stream_set_option</function> should return &false; on failure or
       if the <parameter>option</parameter> is not implemented, &true; otherwise.
      </para>
     </listitem>
    </varlistentry>
   </variablelist>
  </para>
 </refsect1>

 <refsect1 role="returnvalues">
  &reftitle.returnvalues;
  <para>
   &return.success;
  </para>
  <para>
   <function>stream_wrapper_register</function> will return &false; if the
   <parameter>protocol</parameter> already has a handler.
  </para>
 </refsect1>

 <refsect1 role="changelog"><!-- {{{ -->
  &reftitle.changelog;
  <para>
   <informaltable>
    <tgroup cols="2">
     <thead>
      <row>
       <entry>&Version;</entry>
       <entry>&Description;</entry>
      </row>
     </thead>
     <tbody>
      <row>
       <entry>5.3.0</entry>
       <entry>
        Added the following userspace wrappers: stream_set_option, stream_cast.
       </entry>
      </row>
      <row>
       <entry>5.0.0</entry>
       <entry>
        Added the following userspace wrappers: rmdir, mkdir, rename, unlink.
       </entry>
      </row>
      <row>
       <entry>5.0.0</entry>
       <entry>
        Added the <literal>context</literal> property.
       </entry>
      </row>
     </tbody>
    </tgroup>
   </informaltable>
  </para>
 </refsect1><!-- }}} -->

 <refsect1 role="examples"><!-- {{{ -->
  &reftitle.examples;
  <para>
   <example>
    <title>A Stream for reading/writing global variables</title>
    <para>
     The example below implements a var:// protocol handler that allows
     read/write access to a named global variable using standard filesystem
     stream functions such as <function>fread</function>. The var:// protocol
     implemented below, given the URL "var://foo" will read/write data
     to/from $GLOBALS["foo"].
    </para>
    <programlisting role="php">
<![CDATA[
<?php

class VariableStream {
    var $position;
    var $varname;

    function stream_open($path, $mode, $options, &$opened_path)
    {
        $url = parse_url($path);
        $this->varname = $url["host"];
        $this->position = 0;

        return true;
    }

    function stream_read($count)
    {
        $ret = substr($GLOBALS[$this->varname], $this->position, $count);
        $this->position += strlen($ret);
        return $ret;
    }

    function stream_write($data)
    {
        $left = substr($GLOBALS[$this->varname], 0, $this->position);
        $right = substr($GLOBALS[$this->varname], $this->position + strlen($data));
        $GLOBALS[$this->varname] = $left . $data . $right;
        $this->position += strlen($data);
        return strlen($data);
    }

    function stream_tell()
    {
        return $this->position;
    }

    function stream_eof()
    {
        return $this->position >= strlen($GLOBALS[$this->varname]);
    }

    function stream_seek($offset, $whence)
    {
        switch ($whence) {
            case SEEK_SET:
                if ($offset < strlen($GLOBALS[$this->varname]) && $offset >= 0) {
                     $this->position = $offset;
                     return true;
                } else {
                     return false;
                }
                break;

            case SEEK_CUR:
                if ($offset >= 0) {
                     $this->position += $offset;
                     return true;
                } else {
                     return false;
                }
                break;

            case SEEK_END:
                if (strlen($GLOBALS[$this->varname]) + $offset >= 0) {
                     $this->position = strlen($GLOBALS[$this->varname]) + $offset;
                     return true;
                } else {
                     return false;
                }
                break;

            default:
                return false;
        }
    }
}

stream_wrapper_register("var", "VariableStream")
    or die("Failed to register protocol");

$myvar = "";

$fp = fopen("var://myvar", "r+");

fwrite($fp, "line1\n");
fwrite($fp, "line2\n");
fwrite($fp, "line3\n");

rewind($fp);
while (!feof($fp)) {
    echo fgets($fp);
}
fclose($fp);
var_dump($myvar);

?>
]]>
    </programlisting>
   </example>
  </para>

 </refsect1><!-- }}} -->

</refentry>


<!-- Keep this comment at the end of the file
Local variables:
mode: sgml
sgml-omittag:t
sgml-shorttag:t
sgml-minimize-attributes:nil
sgml-always-quote-attributes:t
sgml-indent-step:1
sgml-indent-data:t
indent-tabs-mode:nil
sgml-parent-document:nil
sgml-default-dtd-file:"../../../../manual.ced"
sgml-exposed-tags:nil
sgml-local-catalogs:nil
sgml-local-ecat-files:nil
End:
vim600: syn=xml fen fdm=syntax fdl=2 si
vim: et tw=78 syn=sgml
vi: ts=1 sw=1
-->
