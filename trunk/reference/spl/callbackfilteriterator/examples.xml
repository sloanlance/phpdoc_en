<?xml version="1.0" encoding="utf-8"?>
<!-- $Revision$ -->
<chapter xml:id="callbackfilteriterator.examples" xmlns="http://docbook.org/ns/docbook" xmlns:xlink="http://www.w3.org/1999/xlink">
 <title>CallbackFilterIterator &amp; RecursiveCallbackFilterIterator Examples</title>
 <para>
  The main purpose of the <classname>CallbackFilterIterator</classname> and
  <classname>RecursiveCallbackFilterIterator</classname> classes is to
  filter the contents of an iterator using a callback rather than having 
  to go to the trouble of creating a bespoke class extending 
  the abstract <classname>FilterIterator</classname>.
 </para>
 
 <para>
  The callback should accept up to three arguments:
  the current item, the current key and the iterator, respectively.
 </para>

 <example xml:id="callbackfilteriterator.examples.args">
  <title>Available callback arguments</title>
  <programlisting role="php">
<![CDATA[
<?php

/**
 * Callback for CallbackFilterIterator
 *
 * @param $current   Current item's value
 * @param $key       Current item's key
 * @param $iterator  Iterator being filtered
 * @return boolean   TRUE to accept the current item, FALSE otherwise
 */
function my_callback($current, $key, $iterator) {
    // Your filtering code here
}

?>
]]>
  </programlisting>
 </example>
  
 <para>
  Any <type>callback</type> may be used; such as a string containing a 
  function name, an array for a method, or an anonymous 
  function.
 </para>
  
 <example xml:id="callbackfilteriterator.examples.basic">
  <title>Callback basic examples</title>
  <programlisting role="php">
<![CDATA[
<?php

$dir = new FilesystemIterator(__DIR__);

// Filter large files ( > 100MB)
function is_large_file($current) {
    return $current->isFile() && $current->getSize() > 104857600;
}
$large_files = new CallbackFilterIterator($dir, 'is_large_file');

// Filter directories
$files = new CallbackFilterIterator($dir, function ($current, $key, $iterator) {
    return $current->isDir() && ! $iterator->isDot();
});

?>
]]>
  </programlisting>
 </example>
 
 <para>
  Filtering a recursive iterator generally involves two conditions.
  The first is that, to allow recursion, the callback function should return &true;
  if the current iterator item has children.
  The second is the normal filter condition, such as a file size or extension check as
  in the example below.
 </para>
 
 <example xml:id="callbackfilteriterator.examples.recursive">
  <title>Recursive callback basic examples</title>
  <programlisting role="php">
<![CDATA[
<?php

$dir = new FilesystemIterator(__DIR__);

// Filter large files ( > 100MB)
$files = new CallbackFilterIterator($dir, function ($current, $key, $iterator) {
    // Allow recursion
    if ($iterator->hasChildren()) {
        return TRUE;
    }
    // Check for large file
    if ($current->isFile() && $current->getSize() > 104857600) {
        return TRUE;
    }
    return FALSE;
});
 
foreach (new RecursiveIteratorIterator($files) as $file) {
    echo $file->getPathname() . PHP_EOL;
}

?>
]]>
  </programlisting>
 </example>
 
</chapter>

<!-- Keep this comment at the end of the file
Local variables:
mode: sgml
sgml-omittag:t
sgml-shorttag:t
sgml-minimize-attributes:nil
sgml-always-quote-attributes:t
sgml-indent-step:1
sgml-indent-data:t
indent-tabs-mode:nil
sgml-parent-document:nil
sgml-default-dtd-file:"~/.phpdoc/manual.ced"
sgml-exposed-tags:nil
sgml-local-catalogs:nil
sgml-local-ecat-files:nil
End:
vim600: syn=xml fen fdm=syntax fdl=2 si
vim: et tw=78 syn=sgml
vi: ts=1 sw=1
-->
