<?xml version="1.0" encoding="iso-8859-9"?>
<!-- $Revision: 1.38 $ -->
 <chapter id="tutorial">
  <title>Basit bir eðitmen</title>

  <para>
  Bu bölümde PHP ile ilgili en temel bilgileri kýsa ve basit bir eðitmen
  üzerinde anlatmak istiyoruz. Bu metin yalnýzca PHP ile dinamik web sayfasý
  geliþtirmeyi ele alýr, ancak PHP yalnýzca web sayfasý yaratmakla
  sýnýrlý deðildir. Daha fazla bilgi için <link linkend="intro-whatcando">PHP
  neler yapabilir</link> bölümünü inceleyebilirsiniz.
  </para>
  <para>
  PHP-etkin web sayfalarý normal HTML sayfalarý gibidir ve bu sayfalarý
  normal HTML sayfalarý için kullandýðýnýz yöntemlerle yaratabilir ve
  düzenleyebilirsiniz.
  </para>

  <sect1 id="tutorial.requirements">
   <title>Neye ihtiyacým var?</title>
   <para>
   Bu eðitmen süresince web sunucunuzun PHP desteðinin etkinleþtirilmiþ
   olduðunu ve tüm <filename>.php</filename> uzantýlý dosyalarýn
   PHP tarafýndan kontrol ediliyor olduðunu öngöreceðiz. Birçok sunucuda,
   bu uzantý PHP dosyalarý için öntanýmlý dosya uzantýsýdýr, ancak emin
   olmak için sunucunuzun yöneticisinden doðru bilgiyi edinebilirsiniz.
   Sunucunuz PHP&apos;yi destekliyorsa, hiçbir þey yapmanýza gerek
   yoktur. Yalnýzca <filename>.php</filename> uzantýlý dosyalarýnýzý
   yaratmanýz ve web klasörünüze koymanýz, sunucunuzun bu dosyayý
   sizin için otomatik olarak iþleme koymasý için yeterli olacaktýr.
   Herhangi bir þeyi derlemeniz ya da ekstra bir araç kurulumu yapmanýz
   gerekmemektedir. PHP-etkin dosyalarý yeni bir tür HTML dosyasý olarak
   kafanýzda canlandýrabilirsiniz. Düþünün ki, artýk HTML dosyasýnýn içine
   sihirli birtakým etiketler koyabiliyor ve bu etiketler sayesinde istediðiniz
   her tür iþlemi gerçekleþtirebiliyorsunuz. Birçok web barýndýrma sitesi
   PHP desteði sunmaktadýr, ancak sizinki sunmuyorsa, <ulink url="&url.php.links;">
   PHP Baðlantýlarý</link> bölümünden PHP hizmeti sunan web barýndýrma
   sitelerinin adreslerine ulaþabilirsiniz.
      </para>
   <para>
   Diyelim ki çok deðerli olan band geniþliðinizi boþa harcamamak ve kendi
   sisteminizde yerel olarak geliþtirme yapmak istiyorsunuz. Bu durumda, 
   <ulink url="&url.apache;">Apache</ulink> gibi bir web sunucusunu ve elbette
   <ulink url="&url.php.downloads;">PHP</ulink>&apos;yi
   indirmeniz ve kurmanýz gerekmektedir. Bu ikilinin yanýnda, <ulink url="&url.mysql.docs;">MySQL</ulink>
   gibi bir veritabanýný da indirip kurmanýz iyi olacaktýr.
   </para>
   <para>
   Bu üçlüyü kendi baþýnýza kurabilir ya da daha basit bir yol izleyebilirsiniz. Kýlavuzumuz
   <link linkend="install">PHP için kurulum bilgileri</link> (web sunucunuzun
   halihazýrda kurulu olduðunu öngörür) bölümüne sahiptir. PHP&apos;yi kendiniz
   kurmakta sorun yaþýyorsanýz, sorularýnýzýn çözümü için <ulink url="&url.php.mailing-lists;">kurulum
    posta listesi</ulink>&apos;ne baþvurabilirsiniz. Daha basit bir yoldan gitmek istiyorsanýz,
    iþletim sisteminize uygun olan <ulink url="&url.installkits;">ön yapýlandýrýlmýþ paket</ulink>i
    seçebilir ve tüm bu araçlarý birkaç fare týklamasýyla otomatik olarak yükleyebilirsiniz.
    MacOSX, Linux ve Windows dahil olmak üzere birçok iþletim sistemine PHP destekli bir web
    sunucusu kurmak oldukça kolaydýr. Linux üzerinde, <ulink url="&url.rpmfind;">rpmfind</ulink>
    ve <ulink url="&url.rpmfind.pbone;">PBone</ulink> araçlarý RPM dosyalarýný bulmanýzda
    size yardýmcý olacaklardýr. Debian için ise <ulink url="&url.apt-get;">apt-get</ulink>
    bölümünü ziyaret edebilirsiniz.
      </para>
  </sect1>

  <sect1 id="tutorial.firstpage">
   <title>Ýlk PHP-etkin sayfanýz</title>
   <para>
   <filename>hello.php</filename> isimli bir dosya yaratýn ve web sunucunuzun
   kök klasörüne (<varname>DOCUMENT_ROOT</varname>) aþaðýdaki içerikle
   beraber kaydedin:
   </para>
   <para>
    <example>
     <title>Ýlk PHP betiðimiz: <filename>hello.php</filename></title>
     <programlisting role="php">
<![CDATA[
<html>
 <head>
  <title>PHP Test</title>
 </head>
 <body>
 <?php echo '<p>Merhaba Dünya</p>'; ?>
 </body>
</html>
]]>
     </programlisting>
     <simpara>
     Tarayýcýnýzý kullanarak web sunucunuzun URL adresine eriþebilirsiniz, adres
     bölümünün sonuna "/hello.php" eklemeniz yeterli olacaktýr. Yerel olarak geliþtirme
     yaparken bu URL <literal>http://localhost/hello.php</literal> ya da
     <literal>http://127.0.0.1/hello.php</literal> gibi bir þey olacaktýr, ancak
     bu web sunucusunun yapýlandýrma ayarlarýna baðlýdýr. Eðer her þey düzgün
     yapýlandýrýlmýþsa, bu dosya PHP tarafýndan iþlenecek ve aþaðýdaki çýktý
     tarayýcýnýza gönderilecektir:
     </simpara>
     <screen role="html">
<![CDATA[
<html>
 <head>
  <title>PHP Test</title>
 </head>
 <body>
 <p>Merhaba Dünya</p>
 </body>
</html>
]]>
     </screen>
    </example>
   </para>
   <para>
   Bu program gördüðünüz gibi son derece basit ve esasýnda böyle bir sayfa yaratmanýz için
   PHP&apos;ye gereksiniminiz yoktur. Görüntülenen: PHP&apos;nin 
   <function>echo</function> komutu kullanýlarak elde edilen <literal>Merhaba Dünya</literal>
   cümlesidir. Bu dosyanýn hiçbir þekilde <emphasis>çalýþtýrýlabilir ya da özel türde olmasýna ihtiyaç duyulmadýðýna</emphasis>
   dikkat edin. Sunucu dosyanýn PHP tarafýndan iþlenmesi gerektiðini bilir çünkü dosyaya ".php" uzantýsýný
   tanýmladýnýz. Sunucu bu uzantýya sahip dosyalarý PHP üzerinden geçirecek biçimde yapýlandýrýlmýþtýr.
   Bunu size birtakým özel etiketlerle birçok ilginç iþlem yapabilmenizi saðlayan bir tür HTML dosyasý
   olarak düþünebilirsiniz.
   </para>
   <para>
   Bu örneði denediyseniz ve hiçbir çýktý alamadýysanýz, sizden dosyayý indirmenizi
   istediyse ya da dosyanýn tüm içeriðini metin olarak ekranda gördüyseniz, büyük ihtimalle
   sunucunuzun PHP desteði etkinleþtirilmemiþtir ya da sunucunuz doðru yapýlandýrýlmamýþtýr.
   Yönetinizden kýlavuzdaki <link linkend="install">Kurulum</link> bölümünü
   kullanarak PHP&apos;yi etkinleþtirmesini rica edebilirsiniz. Yerel olarak geliþtirme yapýyorsanýz,
   kurulum bölümünü okuyarak herþeyin doðru yapýlandýrýldýðýndan emin olun. Size çýktýyý
   saðlayan sunucudaki dosyaya http üzerinden eriþmeye çalýþýp çalýþmadýðýnýzý kontrol edin.
   Dosyayý direk olarak kendi dosya sisteminizden çaðýrýyorsanýz, PHP tarafýndan iþlenmeyecektir.
   Sorun her þeye raðmen devam ediyorsa, <ulink url="&url.php.support;">PHP desteði alma</ulink>
   yöntemlerini kullanmakta tereddüt etmeyin.
   </para>
   <para>
   Bu örneðin amacý özel PHP etiketi formatýný göstermektir. Örnekte
   <literal>&lt;?php</literal> ile PHP etiketinin baþlangýcýný belirledik.
   Sonra PHP komutunu yazdýk ve kapanýþ etiketi <literal>?&gt;</literal>
   kullanarak PHP kipinden çýktýk. Bir HTML dosyasýnda bu yöntemi kullanarak
   istediðiniz yerde PHP kipine girip çýkabilirsiniz. Daha fazla bilgi için, kýlavuzun
   <link linkend="language.basic-syntax">temel PHP sözdimi</link> bölümünü
   okuyabilirsiniz.
   </para>
   
   <note>
    <title>Metin Düzenleyiciler Hakkýnda</title>
    <para>
    PHP dosyalarýný yaratabileceðiniz, düzenleyebileceðiniz ve yönetebileceðiniz
    birçok metin düzenleyici ve Bütünleþik Geliþtirme Ortamý (IDE) bulunmaktadýr.
    Bu araçlarýn bir kýsmý <ulink url="&url.phpeditorlist;">PHP Düzenleyicileri
     Listesi</ulink> bölümünde listelenmiþtir. Sizin önermek istediðiniz bir düzenleyici
     varsa, lütfen yukardaki sayfayý ziyaret edin ve sayfa idarecisinden önermek istediðiniz
     düzenleyiciyi bu listeye eklemesini rica edin. Söz dizimi aydýnlatmasý olan bir düzenleyici
     size yardýmcý olabilir.
    </para>
   </note>
   
   <note>
    <title>Kelime Ýþlemciler Hakkýnda</title>
    <para>
    StarOffice Writer, Microsoft Word ve Abiword gibi kelime iþlemciler PHP dosyalarýný
    düzenlemek için uygun deðillerdir. Eðer bu test betiði için bunlardan birini kullanmak
    istiyorsanýz, dosyanýn <emphasis>salt metin</emphasis> olarak kaydedildiðinden
    emin olun, aksi takdirde PHP&apos;nin betiði okumasý ve çalýþtýrmasý mümkün olmayacaktýr.
    </para>
   </note>
   
   <note>
    <title>Windows Not Defteri Hakkýnda</title>
    <para>
    PHP betiklerinizi Windows Not Defteri ile yazýyorsanýz, dosyalarýnýzýn .php uzantýsý
    ile kaydedildiðinden emin olmalýsýnýz (Notepad birazdan bahsedeceðimiz önlemleri
    almadýðýnýz takdirde dosyalarýn sonuna otomatik olarak .txt uzantýsý ekler).
    Dosyayý kaydetmek istediðinizde, sizden dosyanýz için bir isim belirtmeniz istenecektir.
    Dosya ismi olarak týrnak içinde (örn. "<filename>hello.php</filename>") yazýn.
    Alternatif olarak, 'Kaydet' iletiþim kutusunun içindeki &apos;Metin Belgeleri&apos; açýlýr menüsüne
    týkladýktan sonra buradaki deðeri "Tüm Dosyalar" olarak deðiþtirin. Artýk dosya isminizi
    týrnak iþareti kullanmadan yazabilirsiniz.
    </para>
   </note>
  
   <para>
    Now that you have successfully created a working PHP script, it is
    time to create the most famous PHP script!  Make a call to the
    <function>phpinfo</function> function and you will see a lot of useful
    information about your system and setup such as available
    <link linkend="language.variables.predefined">predefined variables</link>, 
    loaded PHP modules, and <link linkend="configuration">configuration</link>
    settings. Take some time and review this important information.
   </para>
   <para>
    <example>
     <title>Get system information from PHP</title>
     <programlisting role="php">
<![CDATA[
<?php phpinfo(); ?>
]]>
     </programlisting>
    </example>
   </para>
  </sect1>

  <sect1 id="tutorial.useful">
   <title>Something Useful</title>
   <para>
    Let us do something more useful now. We are going to check
    what sort of browser the visitor is using.
    For that, we check the user agent string the browser
    sends as part of the HTTP request. This information is stored in a <link
    linkend="language.variables">variable</link>. Variables always start
    with a dollar-sign in PHP. The variable we are interested in right now 
    is <varname>$_SERVER['HTTP_USER_AGENT']</varname>.
   </para>
   <note>
    <para>
     <link linkend="reserved.variables.server">$_SERVER</link> is a 
     special reserved PHP variable that contains all web server information.
     It is known as an autoglobal (or superglobal).  See the related manual page on
     <link linkend="language.variables.superglobals">superglobals</link>
     for more information.  These special variables were introduced in PHP 
     <ulink url="&url.php.release4.1.0;">4.1.0</ulink>.  Before this time, we used
     the older <varname>$HTTP_*_VARS</varname> arrays instead,
     such as <varname>$HTTP_SERVER_VARS</varname>.  Although deprecated, 
     these older variables still exist.  (See also the note on
     <link linkend="tutorial.oldcode">old code</link>.)
    </para>
   </note>
   <para>
    To display this variable, you can simply do:
   </para>
   <para>
    <example>
    <title>Printing a variable (Array element)</title>
    <programlisting role="php">
<![CDATA[
<?php echo $_SERVER['HTTP_USER_AGENT']; ?>
]]>
    </programlisting>
    <para>
     A sample output of this script may be:
    </para>
    <screen role="html">
Mozilla/4.0 (compatible; MSIE 6.0; Windows NT 5.1)
    </screen>
   </example>
   </para>
   <para>
    There are many <link linkend="language.types">types</link> of 
    variables available in PHP.  In the above example we printed 
    an <link linkend="language.types.array">Array</link> element.
    Arrays can be very useful.
   </para>
   <para>
    <varname>$_SERVER</varname> is just one variable that PHP automatically 
    makes available to you. A list can be seen in the 
    <link linkend="reserved.variables">Reserved Variables</link> section 
    of the manual or you can get a complete list of them by looking at
    the output of the <function>phpinfo</function> function used in the
    example in the previous section.
   </para>
   <para>
    You can put multiple PHP statements inside a PHP tag and create
    little blocks of code that do more than just a single echo.
    For example, if you want to check for Internet Explorer you
    can do this:
   </para>
   <para>
    <example>
     <title>Example using <link linkend="language.control-structures">control 
     structures</link> and <link linkend="language.functions">functions</link></title>
     <programlisting role="php">
<![CDATA[
<?php
if (strpos($_SERVER['HTTP_USER_AGENT'], 'MSIE') !== FALSE) {
    echo 'You are using Internet Explorer.<br />';
}
?>
]]>
     </programlisting>
     <para>
      A sample output of this script may be:
     </para>
     <screen role="html">
<![CDATA[
You are using Internet Explorer.<br />
]]>
     </screen>
    </example>
   </para>
   <para>
    Here we introduce a couple of new concepts. We have an 
    <link linkend="control-structures.if">if</link> statement.
    If you are familiar with the basic syntax used by the C
    language, this should look logical to you. Otherwise, you
    should probably pick up an introductory PHP book and read the first
    couple of chapters, or read the <link linkend="langref">Language
    Reference</link> part of the manual. You can find a list of PHP books
    at <ulink url="&url.php.books;">&url.php.books;</ulink>.
   </para>
   <para>
    The second concept we introduced was the <function>strpos</function>
    function call. <function>strpos</function> is a function built into
    PHP which searches a string for another string. In this case we are
    looking for <literal>'MSIE'</literal> (so-called needle) inside
    <varname>$_SERVER['HTTP_USER_AGENT']</varname> (so-called haystack).  If
    the needle is found inside the haystack, the function returns the position
    of the needle relative to the start of the haystack.  Otherwise, it
    returns &false;.  If it does not return &false;, the <link
    linkend="control-structures.if">if</link> expression evaluates to &true;
    and the code within its {braces} is executed. Otherwise, the code is not
    run. Feel free to create similar examples, 
    with <link linkend="control-structures.if">if</link>, 
    <link linkend="control-structures.else">else</link>, and other 
    functions such as <function>strtoupper</function> and 
    <function>strlen</function>.  Each related manual page contains examples 
    too.  If you are unsure how to use functions, you will want to read both
    the manual page on <link linkend="about.prototypes">how to read a
    function definition</link> and the section about  
    <link linkend="language.functions">PHP functions</link>.
   </para>
   <para>
    We can take this a step further and show how you can jump in and out
    of PHP mode even in the middle of a PHP block:
   </para>
   <para>
    <example>
     <title>Mixing both HTML and PHP modes</title>
     <programlisting role="php">
<![CDATA[
<?php
if (strpos($_SERVER['HTTP_USER_AGENT'], 'MSIE') !== FALSE) {
?>
<h3>strpos() must have returned non-false</h3>
<p>You are using Internet Explorer</p>
<?php
} else {
?>
<h3>strpos() must have returned false</h3>
<p>You are not using Internet Explorer</p>
<?php
}
?>
]]>
     </programlisting>
     <para>
      A sample output of this script may be:
     </para>
     <screen role="html">
<![CDATA[
<h3>strpos() must have returned non-false</h3>
<p>You are using Internet Explorer</p>
]]>
     </screen>
    </example>
   </para>
   <para>
    Instead of using a PHP echo statement to output something, we jumped out
    of PHP mode and just sent straight HTML. The important and powerful point
    to note here is that the logical flow of the script remains intact. Only
    one of the HTML blocks will end up getting sent to the viewer depending on
    the result of <function>strpos</function>.  In other words, it depends on
    whether the string <literal>MSIE</literal> was found or not.
   </para>
  </sect1>
   
  <sect1 id="tutorial.forms">
   <title>Dealing with Forms</title>
   <para>
    One of the most powerful features of PHP is the way it handles HTML
    forms. The basic concept that is important to understand is that any
    form element will automatically be available to your PHP 
    scripts.  Please read the manual section on
    <link linkend="language.variables.external">Variables from outside 
    of PHP</link> for more information and examples on using forms 
    with PHP.  Here is an example HTML form:
   </para>
   <para>
    <example>
     <title>A simple HTML form</title>
     <programlisting role="html">
<![CDATA[
<form action="action.php" method="post">
 <p>Your name: <input type="text" name="name" /></p>
 <p>Your age: <input type="text" name="age" /></p>
 <p><input type="submit" /></p>
</form>
]]>
     </programlisting>
    </example>
   </para>
   <para>
    There is nothing special about this form. It is a straight HTML form
    with no special tags of any kind. When the user fills in this form
    and hits the submit button, the <filename>action.php</filename> page
    is called. In this file you would write something like this:
   </para>
   <para>
    <example>
     <title>Printing data from our form</title>
     <programlisting role="php">
<![CDATA[
Hi <?php echo $_POST['name']; ?>.
You are <?php echo $_POST['age']; ?> years old.
]]>
     </programlisting>
     <para>
      A sample output of this script may be:
     </para>
     <screen role="html">
<![CDATA[
Hi Joe. You are 22 years old.
]]>
     </screen>
    </example>
   </para>
   <para>
    It should be obvious what this does. There is nothing more to it.
    The <varname>$_POST['name']</varname> and <varname>$_POST['age']</varname>
    variables are automatically set for you by PHP.  Earlier we
    used the <varname>$_SERVER</varname> autoglobal; above we just 
    introduced the <link linkend="reserved.variables.post">$_POST</link>
    autoglobal which contains all POST data.  Notice how the
    <emphasis>method</emphasis> of our form is POST.  If we used the 
    method <emphasis>GET</emphasis> then our form information would live in 
    the <link linkend="reserved.variables.get">$_GET</link> autoglobal instead.
    You may also use the <link linkend="reserved.variables.request">$_REQUEST</link>
    autoglobal, if you do not care about the source of your request data. It 
    contains the merged information of GET, POST and COOKIE data.  Also see the 
    <function>import_request_variables</function> function.
   </para>
   <para>
    You can also deal with XForms input in PHP, although you will find yourself
    comfortable with the well supported HTML forms for quite some time.
    While working with XForms is not for beginners, you might be interested
    in them. We also have a <link linkend="features.xforms">short introduction
    to handling data received from XForms</link> in our features section. 
   </para>
  </sect1>

  <sect1 id="tutorial.oldcode">
   <title>Using old code with new versions of PHP</title>
   <para>
    Now that PHP has grown to be a popular scripting language, there are
    a lot of public repositories and libraries containing code you can reuse.
    The PHP developers have largely tried to preserve backwards compatibility, 
    so a script written for an older version will run (ideally) without changes
    in a newer version of PHP. In practice, some changes will usually be needed.
   </para>
   <para>
    Two of the most important recent changes that affect old code are:
    <itemizedlist>
     <listitem>
      <simpara>
       The deprecation of the old <varname>$HTTP_*_VARS</varname> arrays
       (which need to be indicated as global when used inside a function or
       method).  The following 
       <link linkend="language.variables.superglobals">autoglobal arrays</link>
       were introduced in PHP <ulink url="&url.php.release4.1.0;">4.1.0</ulink>. 
       They are: <varname>$_GET</varname>, <varname>$_POST</varname>, 
       <varname>$_COOKIE</varname>, <varname>$_SERVER</varname>, 
       <varname>$_FILES</varname>, <varname>$_ENV</varname>,
       <varname>$_REQUEST</varname>, and <varname>$_SESSION</varname>.  The
       older <varname>$HTTP_*_VARS</varname> arrays, such as
       <varname>$HTTP_POST_VARS</varname>, still exist as they have since PHP 3. 
       &avail.register-long-arrays;
      </simpara>
     </listitem>
     <listitem>
      <simpara>
       External variables are no longer registered in the global scope by
       default.  In other words, as of PHP
       <ulink url="&url.php.release4.2.0;">4.2.0</ulink> the PHP directive 
       <link linkend="ini.register-globals">register_globals</link> is 
       <emphasis>off</emphasis> by default in &php.ini;. The preferred 
       method of accessing these values is via the autoglobal arrays mentioned
       above.  Older scripts, books, and tutorials may rely on this 
       directive being on.  If it were on, for example, one could use 
       <varname>$id</varname> from the URL 
       <literal>http://www.example.com/foo.php?id=42</literal>.  Whether on 
       or off, <varname>$_GET['id']</varname> is available.
      </simpara>
     </listitem>
    </itemizedlist>
    For more details on these changes, see the section on 
    <link linkend="language.variables.predefined">predefined variables</link>
    and links therein.
   </para>
  </sect1>
  
  <sect1 id="tutorial.whatsnext">
   <title>What's next?</title>
   <para>
    With your new knowledge you should be able to understand most of 
    the manual and also the various example scripts available in the
    example archives. You can also find other examples on the php.net
    websites in the links section:
    <ulink url="&url.php.links;">&url.php.links;</ulink>.
   </para>
   <para>
    To view various slide presentations that show more of what PHP can do, 
    see the PHP Conference Material Sites: <ulink url="&url.php.conf;">
    &url.php.conf;</ulink> and <ulink url="&url.php.talks;">&url.php.talks;
    </ulink>
   </para>
  </sect1>
 </chapter>

<!-- Keep this comment at the end of the file
Local variables:
mode: sgml
sgml-omittag:t
sgml-shorttag:t
sgml-minimize-attributes:nil
sgml-always-quote-attributes:t
sgml-indent-step:1
sgml-indent-data:t
indent-tabs-mode:nil
sgml-parent-document:nil
sgml-default-dtd-file:"../../manual.ced"
sgml-exposed-tags:nil
sgml-local-catalogs:nil
sgml-local-ecat-files:nil
End:
vim600: syn=xml fen fdm=syntax fdl=2 si
vim: et tw=78 syn=sgml
vi: ts=1 sw=1
-->

